import bag

# private variables
sequential net
net = bag.empty()
id = 0
dup = False
drop = False

# public functions
def send(src, dst, payload):
	var msg = {.src:src,.dst:dst,.payload:payload, .id:id}
	atomically:
		net = bag.add(net, msg)
#		if dup and choose({True,False}):
#			net = bag.add(net, msg)
#if drop and choose({True, False}):
#			net = bag.remove(net, msg)
		id += 1

def receive(pid) returns msg:
	atomically:
		var msgs = {(m,c) for m:c in net where (pid == m.dst)}
		if len(msgs) > 0:
			msg = (choose(msgs))[0]
			net = bag.remove(net, msg)
#			if drop and choose({True,False}):
#				msg = {:}
		else:
			msg = {:}

def dropper():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if (net != bag.empty()):
                            var msg_drop = bag.bchoose(net)
                            net = bag.remove(net, msg_drop)

def duplicator():
    while True:
        if (choose {True, False}):
            atomically var net_cp = net
            when net_cp != net:
                atomically:
                    if (net != bag.empty()):
                        var msg_dup = bag.bchoose(net)
                        net = bag.add(net, msg_dup)

def main():
	send(1,2,"hi");
	send(3,2,"ola");
	receive(2);
	send(2,1,"wow");
	receive(1);
	receive(2);
	assert net == bag.empty()
	
spawn eternal dropper()
spawn eternal duplicator()
spawn main()


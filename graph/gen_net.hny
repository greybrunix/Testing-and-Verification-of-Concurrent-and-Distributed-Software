import bag, list
# private variables
sequential net
net = {}
id = 0


# FL
def construct(flags) returns API:
	if (flags[0] == 0):
		net = bag.empty()
		API = (send1, receive1)
		if (flags[1] == 1):
			spawn eternal duplicator1()
		if (flags[2] == 1):
			spawn eternal dropper1()
	else:
		net = []
		API = (send2, receive2)
		if (flags[1] == 1):
			spawn eternal duplicator2()
		if (flags[2] == 1):
			spawn eternal dropper2()
	

# public functions
def send1(src, dst, payload):
	atomically:
		var msg = {.src:src,.dst:dst,.payload:payload, .id:id}
		net = bag.add(net, msg)
		id += 1

def receive1(pid) returns msg:
	atomically:
		var msgs = { m:c for m:c in net where (pid == m.dst)}
		if msgs != {:}:
			msg = bag.bchoose msgs
			net = bag.remove(net, msg)
		else:
			msg = {:}
def dropper1():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if (net != bag.empty()):
						var msg_drop = bag.bchoose(net)
						net = bag.remove(net, msg_drop)

def duplicator1():
	while choose {True, False}:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if (net != bag.empty()):
						var msg_dup = bag.bchoose(net)
						net = bag.add(net, msg_dup)

def send2(src, dst, payload):
	var msg = {.src:src, .dst:dst, .payload:payload, .id:id}
	atomically:
		var copy_n = net
		net += [msg,]
		id += 1

def receive2(pid) returns msg:
	atomically:
		var msgs = [m for m in net where (pid == m.dst)]
		if len(msgs) > 0:
			msg = list.head(net)
			net = list.tail(net)
		else:
			msg = {:}

def dropper2():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if net != []:
						net = list.tail(net)
def duplicator2():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if net != []:
						net = dup_hd(net)

def find_next(src, network) returns next:
	var found_first = False
	var found_last = False
	next = 0
	for element in network:
		if (element.src == src) and (not found_first):
			found_first = True
		elif (found_first):
			next += 1
		elif (found_first) and (element.src == src):
			found_sec = True

def dup_hd(network) returns l:
	l = []
	var next = find_next(net[0].src, network)
	var n = choose {0..next}
	var found_first = False
	atomically:
		for element in network:
			if (n > 0) and (element.src == net[0].src) and (not found_first):
				found_first = True
			elif (n == 0):
				l += [net[0],]
			elif (found_first):
				n -= 1
			l += [element,]
def remove_elem(elem, network) returns l:
	l = []
	var reached_first = False
	atomically:
		for element in network:
			if ((element != elem) or reached_first):
				l += [element,]
			elif (not reached_first):
				reached_first = True

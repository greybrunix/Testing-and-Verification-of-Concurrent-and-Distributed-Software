import list

sequential net
net = []
id = 0
dup = True
drop = True

def send(src, dst, payload):
	var msg = {.src:src, .dst:dst, .payload:payload, .id:id}
	atomically:
		var copy_n = net
		net += [msg,]
		id += 1

def receive(pid) returns msg:
	atomically:
		var msgs = [m for m in net where (pid == m.dst)]
		if len(msgs) > 0:
			msg = msgs[0]
			net = remove_elem(msg, net)
		else:
			msg = {:}

def dropper():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if net != []:
						var msg_drop = remove_elem(net[0], net)
def duplicator():
	while True:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if net != []:
						net = dup_hd(net)

def find_next(src, network) returns next:
	var found_first = False
	var found_last = False
	next = 0
	for element in network:
		if (element.src == src) and (not found_first): 
			found_first = True
		elif (found_first):
			next += 1
		elif (found_first) and (element.src == src):
			found_sec = True
	
def dup_hd(network) returns l:
	l = []
	var next = find_next(net[0].src, network)
	var n = choose {0..next}
	var found_first = False
	atomically:
		for element in network:
			if (n > 0) and (element.src == net[0].src) and (not found_first):
				found_first = True
			elif (n == 0):
				l += [net[0],]
			elif (found_first):
				n -= 1
			l += [element,]
def remove_elem(elem, network) returns l:
	l = []
	var reached_first = False
	atomically:
		for element in network:
			if ((element != elem) or reached_first):
				l += [element,]
			elif (not reached_first):
				reached_first = True
def main():
    send(1,2,"True")
    send(1,2,"False")
    send(2,1,"True")
    receive(2)
    receive(1)
    send(1,1,"False")
    send(1,3,"True")
    receive(1)
    send(1,1,"True")
    assert net == []
spawn eternal duplicator()
spawn eternal dropper()
spawn main()


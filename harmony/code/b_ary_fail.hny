#critical reached?
#finally  # safety
#invariant reached_crit in {0, 1} # safety

sequential turn, lockTaken, flags
turn = 0
lockTaken = False
flags = [False, False]
counter = 0
# safety -> no two critical sections at one time
# liveness -> if process in wants is 1 -> eventually will reach critical section
# fairness -> all processes eventually reaches the critical section
def fail0 p_q: # trivially allows two processes in critical section
	while choose {False, True}:
		# non crit
		#entering crit
		#crit
		counter += 1
		#leave crit
def fail1 p_q: # may allow two processes in critical section, note
		# T2 chooses true
		# T1 chooses true and sets the lock to true, entes cs
		# T2 chooses true and enters cs
	while choose {False, True}:
		# Enter cs
		await not lockTaken
		lockTaken = True
		#cs
		counter += 1
		#leaving cs
		lockTaken = False
def fail2 p_q: # this implementation reaches a final state with a blocked process
	while choose {False, True}:
		# enter critical
		turn = 1 - p_q
		await turn == p_q
		# critical
		counter += 1
		# leaving critical
		# post protocol
def fail3 p_q: # both block eternally
	while choose {False, True}:
		#entering critical
		flags p_q = True
		await not flags (1 - p_q)
		#crit
		counter += 1
		#leaving
		flags p_q = False
def fail4 p_q:
	while choose {False, True}:
		while not (turn == p_q):
			pass
		#cs
		counter += 1
		turn = 1 - p_q
spawn fail4 0;
spawn fail4 1;

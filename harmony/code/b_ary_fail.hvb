Issue: Non-terminating state

Modules:
  __main__: b_ary_fail.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=3 column=1
  end statement:     line=62 column=7
  source code:       in_cs = 0
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=3 column=1
  end statement:     line=3 column=9
  source code:       in_cs = 0
                             ^
  stack:             [{:}, 0]

Step 3:
  program counter:   2
  hvm code:          Store in_cs
  explanation:       pop value (0) and store into variable in_cs
  source code:       in_cs = 0
                     ^^^^^^^
  shared variables:  { in_cs: 0 }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Push ?turn
  explanation:       push constant ?turn
  start statement:   line=6 column=1
  end statement:     line=6 column=33
  source code:       sequential turn, lockTaken, flags
                                ^^^^
  stack:             [{:}, ?turn]

Step 5:
  program counter:   4
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 6:
  program counter:   5
  hvm code:          Push ?lockTaken
  explanation:       push constant ?lockTaken
  source code:       sequential turn, lockTaken, flags
                                      ^^^^^^^^^
  stack:             [{:}, ?lockTaken]

Step 7:
  program counter:   6
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   7
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  source code:       sequential turn, lockTaken, flags
                                                 ^^^^^
  stack:             [{:}, ?flags]

Step 9:
  program counter:   8
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 10:
  program counter:   9
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=7 column=1
  end statement:     line=7 column=8
  source code:       turn = 0
                            ^
  stack:             [{:}, 0]

Step 11:
  program counter:   10
  hvm code:          Store turn
  explanation:       pop value (0) and store into variable turn
  source code:       turn = 0
                     ^^^^^^
  shared variables:  { in_cs: 0, turn: 0 }
  stack:             [{:}]

Step 12:
  program counter:   11
  hvm code:          Push False
  explanation:       push constant False
  start statement:   line=8 column=1
  end statement:     line=8 column=17
  source code:       lockTaken = False
                                 ^^^^^
  stack:             [{:}, False]

Step 13:
  program counter:   12
  hvm code:          Store lockTaken
  explanation:       pop value (False) and store into variable lockTaken
  source code:       lockTaken = False
                     ^^^^^^^^^^^
  shared variables:  { in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 14:
  program counter:   13
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=1
  end statement:     line=9 column=22
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, []]

Step 15:
  program counter:   14
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = [False, False]
                              ^^^^^
  stack:             [{:}, [], False]

Step 16:
  program counter:   15
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False ]]

Step 17:
  program counter:   16
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = [False, False]
                                     ^^^^^
  stack:             [{:}, [ False ], False]

Step 18:
  program counter:   17
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, [False]); insert first value into the second; push result ([False, False])
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False, False ]]

Step 19:
  program counter:   18
  hvm code:          Store flags
  explanation:       pop value ([False, False]) and store into variable flags
  source code:       flags = [False, False]
                     ^^^^^^^
  shared variables:  { flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 20:
  program counter:   19
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=10 column=1
  end statement:     line=10 column=11
  source code:       counter = 0
                               ^
  stack:             [{:}, 0]

Step 21:
  program counter:   20
  hvm code:          Store counter
  explanation:       pop value (0) and store into variable counter
  source code:       counter = 0
                     ^^^^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 22:
  program counter:   21
  hvm code:          Jump 191
  explanation:       jump over method definition: set program counter to 191
  start statement:   line=11 column=1
  end statement:     line=11 column=14
  source code:       def fail0 p_q:
                     ^^^

Step 23:
  program counter:   191
  hvm code:          Push ?PC(159)
  explanation:       push constant ?PC(159)
  start statement:   line=60 column=1
  end statement:     line=60 column=13
  source code:       spawn fail4 0;
                           ^^^^^
  stack:             [{:}, ?PC(159)]

Step 24:
  program counter:   192
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn fail4 0;
                                 ^
  stack:             [{:}, ?PC(159), 0]

Step 25:
  program counter:   193
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(159)); push result (?PC(159)[0])
  source code:       spawn fail4 0;
                           ^^^^^^^
  stack:             [{:}, ?PC(159)[0]]

Step 26:
  program counter:   194
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn fail4 0;
                     ^^^^^^^^^^^^^
  stack:             [{:}, ?PC(159)[0], {:}]

Step 27:
  program counter:   195
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (0), and pc (159: "fail4"), and spawn thread
  start expression:  line=60 column=1
  end expression:    line=60 column=13
  stack:             [{:}]

Step 28:
  program counter:   196
  hvm code:          Push ?PC(159)
  explanation:       push constant ?PC(159)
  start statement:   line=61 column=1
  end statement:     line=61 column=13
  source code:       spawn fail4 1;
                           ^^^^^
  stack:             [{:}, ?PC(159)]

Step 29:
  program counter:   197
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn fail4 1;
                                 ^
  stack:             [{:}, ?PC(159), 1]

Step 30:
  program counter:   198
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(159)); push result (?PC(159)[1])
  source code:       spawn fail4 1;
                           ^^^^^^^
  stack:             [{:}, ?PC(159)[1]]

Step 31:
  program counter:   199
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn fail4 1;
                     ^^^^^^^^^^^^^
  stack:             [{:}, ?PC(159)[1], {:}]

Step 32:
  program counter:   200
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (159: "fail4"), and spawn thread
  start expression:  line=61 column=1
  end expression:    line=61 column=13
  stack:             [{:}]

Step 33:
  program counter:   201
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=3 column=1
  end statement:     line=62 column=7
  source code:       in_cs = 0
  new mode:          terminated
  stack:             [None]

================================================
Running thread T2: fail4(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=201 terminated atomic __init__()
  T1: pc=159 runnable fail4(0)
    about to run method fail4 with argument 0
shared variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 0
state id: 3
================================================

Step 34:
  program counter:   159
  hvm code:          Frame fail4(p_q)
  explanation:       pop argument (1), assign to p_q, and run method "fail4"
  start statement:   line=50 column=1
  end statement:     line=50 column=14
  source code:       def fail4 p_q:
                     ^^^^^^^^^^^^^^
  method variables:  { p_q: 1 }
  call trace:        fail4(1)
  stack:             [{:}]

Step 35:
  program counter:   160
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=51 column=2
  end statement:     line=51 column=28
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, {}]

Step 36:
  program counter:   161
  hvm code:          Push False
  explanation:       push constant False
  source code:       	while choose {False, True}:
                                    ^^^^^
  stack:             [{:}, {}, False]

Step 37:
  program counter:   162
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False }]

Step 38:
  program counter:   163
  hvm code:          Push True
  explanation:       push constant True
  source code:       	while choose {False, True}:
                                           ^^^^
  stack:             [{:}, { False }, True]

Step 39:
  program counter:   164
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False, True }]

Step 40:
  program counter:   165
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (False)
  source code:       	while choose {False, True}:
                            ^^^^^^^^^^^^^^^^^^^^
  call trace:        fail4(1)
  stack:             [{:}, False]

Step 41:
  program counter:   166
  hvm code:          JumpCond False 189
  explanation:       pop value (False), compare to False, and jump to 189 if the same
  source code:       	while choose {False, True}:
                      ^^^^^
  stack:             [{:}]

Step 42:
  program counter:   189
  hvm code:          DelVar p_q
  explanation:       delete method variable p_q
  start statement:   line=50 column=1
  end statement:     line=50 column=14
  source code:       def fail4 p_q:
                     ^^^^^^^^^^^^^^
  method variables:  { }

Step 43:
  program counter:   190
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start expression:  line=50 column=1
  end expression:    line=50 column=14
  new mode:          terminated
  stack:             [None]

================================================
Running thread T1: fail4(0)
mode:  runnable
stack: ['0']
other threads:
  T0: pc=201 terminated atomic __init__()
  T2: pc=190 terminated fail4(1)
shared variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 0
state id: 11
================================================

Step 44:
  program counter:   159
  hvm code:          Frame fail4(p_q)
  explanation:       pop argument (0), assign to p_q, and run method "fail4"
  start expression:  line=50 column=1
  end expression:    line=50 column=14
  method variables:  { p_q: 0 }
  call trace:        fail4(0)
  stack:             [{:}]

Step 45:
  program counter:   160
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=51 column=2
  end statement:     line=51 column=28
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, {}]

Step 46:
  program counter:   161
  hvm code:          Push False
  explanation:       push constant False
  source code:       	while choose {False, True}:
                                    ^^^^^
  stack:             [{:}, {}, False]

Step 47:
  program counter:   162
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False }]

Step 48:
  program counter:   163
  hvm code:          Push True
  explanation:       push constant True
  source code:       	while choose {False, True}:
                                           ^^^^
  stack:             [{:}, { False }, True]

Step 49:
  program counter:   164
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False, True }]

Step 50:
  program counter:   165
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (True)
  source code:       	while choose {False, True}:
                            ^^^^^^^^^^^^^^^^^^^^
  call trace:        fail4(0)
  stack:             [{:}, True]

Step 51:
  program counter:   166
  hvm code:          JumpCond False 189
  explanation:       pop value (True), compare to False, and jump to 189 if the same
  source code:       	while choose {False, True}:
                      ^^^^^
  stack:             [{:}]

Step 52:
  program counter:   167
  hvm code:          Load turn
  explanation:       push value (0) of variable turn
  start statement:   line=52 column=3
  end statement:     line=52 column=26
  source code:       		while not (turn == p_q):
                                  ^^^^
  call trace:        fail4(0)
  stack:             [{:}, 0]

Step 53:
  program counter:   168
  hvm code:          LoadVar p_q
  explanation:       push value (0) of variable "p_q"
  source code:       		while not (turn == p_q):
                                          ^^^
  stack:             [{:}, 0, 0]

Step 54:
  program counter:   169
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       		while not (turn == p_q):
                                  ^^^^^^^^^^^
  stack:             [{:}, True]

Step 55:
  program counter:   170
  hvm code:          JumpCond True 172
  explanation:       pop value (True), compare to True, and jump to 172 if the same
  source code:       		while not (turn == p_q):
                       ^^^^^
  stack:             [{:}]

Step 56:
  program counter:   172
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=55 column=14
  end statement:     line=55 column=23
  source code:       		atomically in_cs += 1
                                  ^^^^^^^^^^
  call trace:        fail4(0)

Step 57:
  program counter:   173
  hvm code:          Load in_cs
  explanation:       push value (0) of variable in_cs
  start expression:  line=55 column=14
  end expression:    line=55 column=23
  stack:             [{:}, 0]

Step 58:
  program counter:   174
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       		atomically in_cs += 1
                                           ^
  stack:             [{:}, 0, 1]

Step 59:
  program counter:   175
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       		atomically in_cs += 1
                                  ^^^^^^^^^^
  stack:             [{:}, 1]

Step 60:
  program counter:   176
  hvm code:          Store in_cs
  explanation:       pop value (1) and store into variable in_cs
  source code:       		atomically in_cs += 1
                                  ^^^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 1, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 61:
  program counter:   177
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  source code:       		atomically in_cs += 1
                                  ^^^^^^^^^^

Step 62:
  program counter:   178
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=56 column=14
  end statement:     line=56 column=23
  source code:       		atomically in_cs -= 1
                                  ^^^^^^^^^^
  call trace:        fail4(0)

Step 63:
  program counter:   179
  hvm code:          Load in_cs
  explanation:       push value (1) of variable in_cs
  start expression:  line=56 column=14
  end expression:    line=56 column=23
  stack:             [{:}, 1]

Step 64:
  program counter:   180
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       		atomically in_cs -= 1
                                           ^
  stack:             [{:}, 1, 1]

Step 65:
  program counter:   181
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       		atomically in_cs -= 1
                                  ^^^^^^^^^^
  stack:             [{:}, 0]

Step 66:
  program counter:   182
  hvm code:          Store in_cs
  explanation:       pop value (0) and store into variable in_cs
  source code:       		atomically in_cs -= 1
                                  ^^^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 67:
  program counter:   183
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  source code:       		atomically in_cs -= 1
                                  ^^^^^^^^^^

Step 68:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=58 column=3
  end statement:     line=58 column=16
  source code:       		turn = 1 - p_q
                              ^
  stack:             [{:}, 1]

Step 69:
  program counter:   185
  hvm code:          LoadVar p_q
  explanation:       push value (0) of variable "p_q"
  source code:       		turn = 1 - p_q
                                  ^^^
  stack:             [{:}, 1, 0]

Step 70:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 1); the second integer minus the first; push result (1)
  source code:       		turn = 1 - p_q
                              ^^^^^^^
  stack:             [{:}, 1]

Step 71:
  program counter:   187
  hvm code:          Store turn
  explanation:       pop value (1) and store into variable turn
  source code:       		turn = 1 - p_q
                       ^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 1 }
  call trace:        fail4(0)
  stack:             [{:}]

Step 72:
  program counter:   188
  hvm code:          Jump 160
  explanation:       set program counter to 160
  start statement:   line=51 column=2
  end statement:     line=51 column=28
  source code:       	while choose {False, True}:
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 73:
  program counter:   160
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, {}]

Step 74:
  program counter:   161
  hvm code:          Push False
  explanation:       push constant False
  source code:       	while choose {False, True}:
                                    ^^^^^
  stack:             [{:}, {}, False]

Step 75:
  program counter:   162
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False }]

Step 76:
  program counter:   163
  hvm code:          Push True
  explanation:       push constant True
  source code:       	while choose {False, True}:
                                           ^^^^
  stack:             [{:}, { False }, True]

Step 77:
  program counter:   164
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False, True }]

Step 78:
  program counter:   165
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (True)
  source code:       	while choose {False, True}:
                            ^^^^^^^^^^^^^^^^^^^^
  call trace:        fail4(0)
  stack:             [{:}, True]

Step 79:
  program counter:   166
  hvm code:          JumpCond False 189
  explanation:       pop value (True), compare to False, and jump to 189 if the same
  source code:       	while choose {False, True}:
                      ^^^^^
  stack:             [{:}]

================================================
Final state
================================================
Threads:
  T0: pc=201 terminated atomic __init__()
  T1: pc=167 blocked fail4(0)
    about to load variable turn
  T2: pc=190 terminated fail4(1)
Variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 1

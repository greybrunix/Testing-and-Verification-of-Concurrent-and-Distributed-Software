Issue: Non-terminating state

Modules:
  __main__: b_ary_fail.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=3 column=1
  end statement:     line=76 column=7
  source code:       in_cs = 0
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=3 column=1
  end statement:     line=3 column=9
  source code:       in_cs = 0
                             ^
  stack:             [{:}, 0]

Step 3:
  program counter:   2
  hvm code:          Store in_cs
  explanation:       pop value (0) and store into variable in_cs
  source code:       in_cs = 0
                     ^^^^^^^
  shared variables:  { in_cs: 0 }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Jump 48
  explanation:       jump over invariant definition: set program counter to 48
  start statement:   line=5 column=1
  end statement:     line=5 column=93
  source code:       invariant  (in_cs in { 0, 1 }) and (any [entering tid for tid in [0,1]] => one_entered [0,1])
                     ^^^^^^^^^

Step 5:
  program counter:   48
  hvm code:          Invariant 4
  explanation:       test invariant
  source code:       invariant  (in_cs in { 0, 1 }) and (any [entering tid for tid in [0,1]] => one_entered [0,1])
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 6:
  program counter:   49
  hvm code:          Push ?turn
  explanation:       push constant ?turn
  start statement:   line=6 column=1
  end statement:     line=6 column=33
  source code:       sequential turn, lockTaken, flags
                                ^^^^
  stack:             [{:}, ?turn]

Step 7:
  program counter:   50
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   51
  hvm code:          Push ?lockTaken
  explanation:       push constant ?lockTaken
  source code:       sequential turn, lockTaken, flags
                                      ^^^^^^^^^
  stack:             [{:}, ?lockTaken]

Step 9:
  program counter:   52
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 10:
  program counter:   53
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  source code:       sequential turn, lockTaken, flags
                                                 ^^^^^
  stack:             [{:}, ?flags]

Step 11:
  program counter:   54
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential turn, lockTaken, flags
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 12:
  program counter:   55
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=7 column=1
  end statement:     line=7 column=8
  source code:       turn = 0
                            ^
  stack:             [{:}, 0]

Step 13:
  program counter:   56
  hvm code:          Store turn
  explanation:       pop value (0) and store into variable turn
  source code:       turn = 0
                     ^^^^^^
  shared variables:  { in_cs: 0, turn: 0 }
  stack:             [{:}]

Step 14:
  program counter:   57
  hvm code:          Push False
  explanation:       push constant False
  start statement:   line=8 column=1
  end statement:     line=8 column=17
  source code:       lockTaken = False
                                 ^^^^^
  stack:             [{:}, False]

Step 15:
  program counter:   58
  hvm code:          Store lockTaken
  explanation:       pop value (False) and store into variable lockTaken
  source code:       lockTaken = False
                     ^^^^^^^^^^^
  shared variables:  { in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 16:
  program counter:   59
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=9 column=1
  end statement:     line=9 column=22
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, []]

Step 17:
  program counter:   60
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = [False, False]
                              ^^^^^
  stack:             [{:}, [], False]

Step 18:
  program counter:   61
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False ]]

Step 19:
  program counter:   62
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = [False, False]
                                     ^^^^^
  stack:             [{:}, [ False ], False]

Step 20:
  program counter:   63
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, [False]); insert first value into the second; push result ([False, False])
  source code:       flags = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False, False ]]

Step 21:
  program counter:   64
  hvm code:          Store flags
  explanation:       pop value ([False, False]) and store into variable flags
  source code:       flags = [False, False]
                     ^^^^^^^
  shared variables:  { flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 22:
  program counter:   65
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=10 column=1
  end statement:     line=10 column=11
  source code:       counter = 0
                               ^
  stack:             [{:}, 0]

Step 23:
  program counter:   66
  hvm code:          Store counter
  explanation:       pop value (0) and store into variable counter
  source code:       counter = 0
                     ^^^^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 0 }
  stack:             [{:}]

Step 24:
  program counter:   67
  hvm code:          Jump 285
  explanation:       jump over method definition: set program counter to 285
  start statement:   line=11 column=1
  end statement:     line=11 column=14
  source code:       def fail0 p_q:
                     ^^^

Step 25:
  program counter:   285
  hvm code:          Push ?PC(125)
  explanation:       push constant ?PC(125)
  start statement:   line=74 column=1
  end statement:     line=74 column=13
  source code:       spawn fail2 0;
                           ^^^^^
  stack:             [{:}, ?PC(125)]

Step 26:
  program counter:   286
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn fail2 0;
                                 ^
  stack:             [{:}, ?PC(125), 0]

Step 27:
  program counter:   287
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(125)); push result (?PC(125)[0])
  source code:       spawn fail2 0;
                           ^^^^^^^
  stack:             [{:}, ?PC(125)[0]]

Step 28:
  program counter:   288
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn fail2 0;
                     ^^^^^^^^^^^^^
  stack:             [{:}, ?PC(125)[0], {:}]

Step 29:
  program counter:   289
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (0), and pc (125: "fail2"), and spawn thread
  start expression:  line=74 column=1
  end expression:    line=74 column=13
  stack:             [{:}]

Step 30:
  program counter:   290
  hvm code:          Push ?PC(125)
  explanation:       push constant ?PC(125)
  start statement:   line=75 column=1
  end statement:     line=75 column=13
  source code:       spawn fail2 1;
                           ^^^^^
  stack:             [{:}, ?PC(125)]

Step 31:
  program counter:   291
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn fail2 1;
                                 ^
  stack:             [{:}, ?PC(125), 1]

Step 32:
  program counter:   292
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(125)); push result (?PC(125)[1])
  source code:       spawn fail2 1;
                           ^^^^^^^
  stack:             [{:}, ?PC(125)[1]]

Step 33:
  program counter:   293
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn fail2 1;
                     ^^^^^^^^^^^^^
  stack:             [{:}, ?PC(125)[1], {:}]

Step 34:
  program counter:   294
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (125: "fail2"), and spawn thread
  start expression:  line=75 column=1
  end expression:    line=75 column=13
  stack:             [{:}]

Step 35:
  program counter:   295
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=3 column=1
  end statement:     line=76 column=7
  source code:       in_cs = 0
  new mode:          terminated
  stack:             [None]

================================================
Running thread T2: fail2(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=295 terminated atomic __init__()
  T1: pc=125 runnable fail2(0)
    about to run method fail2 with argument 0
shared variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 0
state id: 3
================================================

Step 36:
  program counter:   125
  hvm code:          Frame fail2(p_q)
  explanation:       pop argument (1), assign to p_q, and run method "fail2"
  start statement:   line=30 column=1
  end statement:     line=30 column=14
  source code:       def fail2 p_q:
                     ^^^^^^^^^^^^^^
  method variables:  { p_q: 1 }
  call trace:        fail2(1)
  stack:             [{:}]

Step 37:
  program counter:   126
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=31 column=2
  end statement:     line=31 column=28
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, {}]

Step 38:
  program counter:   127
  hvm code:          Push False
  explanation:       push constant False
  source code:       	while choose {False, True}:
                                    ^^^^^
  stack:             [{:}, {}, False]

Step 39:
  program counter:   128
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False }]

Step 40:
  program counter:   129
  hvm code:          Push True
  explanation:       push constant True
  source code:       	while choose {False, True}:
                                           ^^^^
  stack:             [{:}, { False }, True]

Step 41:
  program counter:   130
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False, True }]

Step 42:
  program counter:   131
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (False)
  source code:       	while choose {False, True}:
                            ^^^^^^^^^^^^^^^^^^^^
  call trace:        fail2(1)
  stack:             [{:}, False]

Step 43:
  program counter:   132
  hvm code:          JumpCond False 156
  explanation:       pop value (False), compare to False, and jump to 156 if the same
  source code:       	while choose {False, True}:
                      ^^^^^
  stack:             [{:}]

Step 44:
  program counter:   156
  hvm code:          DelVar p_q
  explanation:       delete method variable p_q
  start statement:   line=30 column=1
  end statement:     line=30 column=14
  source code:       def fail2 p_q:
                     ^^^^^^^^^^^^^^
  method variables:  { }

Step 45:
  program counter:   157
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start expression:  line=30 column=1
  end expression:    line=30 column=14
  new mode:          terminated
  stack:             [None]

================================================
Running thread T1: fail2(0)
mode:  runnable
stack: ['0']
other threads:
  T0: pc=295 terminated atomic __init__()
  T2: pc=157 terminated fail2(1)
shared variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 0
state id: 11
================================================

Step 46:
  program counter:   125
  hvm code:          Frame fail2(p_q)
  explanation:       pop argument (0), assign to p_q, and run method "fail2"
  start expression:  line=30 column=1
  end expression:    line=30 column=14
  method variables:  { p_q: 0 }
  call trace:        fail2(0)
  stack:             [{:}]

Step 47:
  program counter:   126
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=31 column=2
  end statement:     line=31 column=28
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, {}]

Step 48:
  program counter:   127
  hvm code:          Push False
  explanation:       push constant False
  source code:       	while choose {False, True}:
                                    ^^^^^
  stack:             [{:}, {}, False]

Step 49:
  program counter:   128
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False }]

Step 50:
  program counter:   129
  hvm code:          Push True
  explanation:       push constant True
  source code:       	while choose {False, True}:
                                           ^^^^
  stack:             [{:}, { False }, True]

Step 51:
  program counter:   130
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       	while choose {False, True}:
                                    ^^^^^^^^^^^
  stack:             [{:}, { False, True }]

Step 52:
  program counter:   131
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (True)
  source code:       	while choose {False, True}:
                            ^^^^^^^^^^^^^^^^^^^^
  call trace:        fail2(0)
  stack:             [{:}, True]

Step 53:
  program counter:   132
  hvm code:          JumpCond False 156
  explanation:       pop value (True), compare to False, and jump to 156 if the same
  source code:       	while choose {False, True}:
                      ^^^^^
  stack:             [{:}]

Step 54:
  program counter:   133
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=33 column=3
  end statement:     line=33 column=16
  source code:       		turn = 1 - p_q
                              ^
  stack:             [{:}, 1]

Step 55:
  program counter:   134
  hvm code:          LoadVar p_q
  explanation:       push value (0) of variable "p_q"
  source code:       		turn = 1 - p_q
                                  ^^^
  stack:             [{:}, 1, 0]

Step 56:
  program counter:   135
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 1); the second integer minus the first; push result (1)
  source code:       		turn = 1 - p_q
                              ^^^^^^^
  stack:             [{:}, 1]

Step 57:
  program counter:   136
  hvm code:          Store turn
  explanation:       pop value (1) and store into variable turn
  source code:       		turn = 1 - p_q
                       ^^^^^^
  shared variables:  { counter: 0, flags: [ False, False ], in_cs: 0, lockTaken: False, turn: 1 }
  call trace:        fail2(0)
  stack:             [{:}]

================================================
Final state
================================================
Threads:
  T0: pc=295 terminated atomic __init__()
  T1: pc=137 blocked fail2(0)
    about to load variable turn
  T2: pc=157 terminated fail2(1)
Variables:
  counter: 0
  flags: [ False, False ]
  in_cs: 0
  lockTaken: False
  turn: 1

Issue: Data race (?counter)

Modules:
  alloc: /home/pereirics/venv3.7/lib/python3.7/site-packages/harmony_model_checker/modules/alloc.hny
  bag: /home/pereirics/venv3.7/lib/python3.7/site-packages/harmony_model_checker/modules/bag.hny
  __main__: trivial_fail.hny
  synch: /home/pereirics/venv3.7/lib/python3.7/site-packages/harmony_model_checker/modules/synch.hny
  fork: /home/pereirics/venv3.7/lib/python3.7/site-packages/harmony_model_checker/modules/fork.hny
  list: /home/pereirics/venv3.7/lib/python3.7/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=19 column=7
  source code:       import fork 
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push {:}
  explanation:       push constant {:}
  module:            alloc
  start statement:   line=1 column=1
  end statement:     line=1 column=10
  source code:       pool = {:}
                            ^^^
  stack:             [{:}, {:}]

Step 3:
  program counter:   2
  hvm code:          Store alloc$pool
  explanation:       pop value ({:}) and store into variable alloc$pool
  source code:       pool = {:}
                     ^^^^^^
  shared variables:  { alloc$pool: {:} }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=2 column=1
  end statement:     line=2 column=8
  source code:       next = 0
                            ^
  stack:             [{:}, 0]

Step 5:
  program counter:   4
  hvm code:          Store alloc$next
  explanation:       pop value (0) and store into variable alloc$next
  source code:       next = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 6:
  program counter:   5
  hvm code:          Jump 98
  explanation:       jump over method definition: set program counter to 98
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^

Step 7:
  program counter:   98
  hvm code:          Push PC(101)
  explanation:       push constant PC(101)
  module:            list
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(101)]

Step 8:
  program counter:   99
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (%+) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 9:
  program counter:   100
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 10:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(649)]

Step 11:
  program counter:   647
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (%+) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 12:
  program counter:   648
  hvm code:          Jump 668
  explanation:       jump over method definition: set program counter to 668
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 13:
  program counter:   668
  hvm code:          Push PC(671)
  explanation:       push constant PC(671)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(671)]

Step 14:
  program counter:   669
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (%+) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 15:
  program counter:   670
  hvm code:          Jump 690
  explanation:       jump over method definition: set program counter to 690
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 16:
  program counter:   690
  hvm code:          Push PC(693)
  explanation:       push constant PC(693)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(693)]

Step 17:
  program counter:   691
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (%+) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 18:
  program counter:   692
  hvm code:          Jump 709
  explanation:       jump over method definition: set program counter to 709
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 19:
  program counter:   709
  hvm code:          Push PC(712)
  explanation:       push constant PC(712)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(712)]

Step 20:
  program counter:   710
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (%+) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 21:
  program counter:   711
  hvm code:          Jump 737
  explanation:       jump over method definition: set program counter to 737
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 22:
  program counter:   737
  hvm code:          Push PC(740)
  explanation:       push constant PC(740)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(740)]

Step 23:
  program counter:   738
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (%+) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 24:
  program counter:   739
  hvm code:          Jump 766
  explanation:       jump over method definition: set program counter to 766
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 25:
  program counter:   766
  hvm code:          Push PC(769)
  explanation:       push constant PC(769)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(769)]

Step 26:
  program counter:   767
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (%+) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 27:
  program counter:   768
  hvm code:          Jump 1317
  explanation:       jump over method definition: set program counter to 1317
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 28:
  program counter:   1317
  hvm code:          Push 10
  explanation:       push constant 10
  module:            __main__
  start statement:   line=3 column=1
  end statement:     line=3 column=4
  source code:       I=10;
                       ^^
  stack:             [{:}, 10]

Step 29:
  program counter:   1318
  hvm code:          Store I
  explanation:       pop value (10) and store into variable I
  source code:       I=10;
                     ^^
  shared variables:  { I: 10, alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 30:
  program counter:   1319
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=4 column=1
  end statement:     line=4 column=11
  source code:       counter = 0;
                               ^
  stack:             [{:}, 0]

Step 31:
  program counter:   1320
  hvm code:          Store counter
  explanation:       pop value (0) and store into variable counter
  source code:       counter = 0;
                     ^^^^^^^^^
  shared variables:  { I: 10, alloc$next: 0, alloc$pool: {:}, counter: 0 }
  stack:             [{:}]

Step 32:
  program counter:   1321
  hvm code:          Jump 1397
  explanation:       jump over method definition: set program counter to 1397
  start statement:   line=5 column=1
  end statement:     line=5 column=19
  source code:       def incrementer id:
                     ^^^

Step 33:
  program counter:   1397
  hvm code:          Push ?PC(1346)
  explanation:       push constant ?PC(1346)
  start statement:   line=18 column=1
  end statement:     line=18 column=12
  source code:       spawn main()
                           ^^^^
  stack:             [{:}, ?PC(1346)]

Step 34:
  program counter:   1398
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn main()
                               ^^
  stack:             [{:}, ?PC(1346), []]

Step 35:
  program counter:   1399
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([], ?PC(1346)); push result (?PC(1346)[[]])
  source code:       spawn main()
                           ^^^^^^
  stack:             [{:}, ?PC(1346)[[]]]

Step 36:
  program counter:   1400
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn main()
                     ^^^^^^^^^^^^
  stack:             [{:}, ?PC(1346)[[]], {:}]

Step 37:
  program counter:   1401
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([]), and pc (1346: "main"), and spawn thread
  start expression:  line=18 column=1
  end expression:    line=18 column=12
  stack:             [{:}]

Step 38:
  program counter:   1402
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=19 column=7
  source code:       import fork 
  new mode:          terminated
  stack:             [None]

================================================
Running thread T1: main()
mode:  runnable
stack: ['[]']
other threads:
  T0: pc=1402 terminated atomic __init__()
shared variables:
  I: 10
  alloc$next: 0
  alloc$pool: {:}
  counter: 0
state id: 2
================================================

Step 39:
  program counter:   1346
  hvm code:          Frame main()
  explanation:       pop argument () and run method "main"
  start statement:   line=13 column=1
  end statement:     line=13 column=11
  source code:       def main():
                     ^^^^^^^^^^^
  call trace:        main()
  stack:             [{:}]

Step 40:
  program counter:   1347
  hvm code:          Push {}
  explanation:       initialize accumulator for set comprehension: push constant {}
  start statement:   line=14 column=9
  end statement:     line=14 column=67
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 41:
  program counter:   1348
  hvm code:          StoreVar $accu1118
  explanation:       pop value ({}) and store locally in variable \"$accu1118\"
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { $accu1118: {} }
  stack:             [{:}]

Step 42:
  program counter:   1349
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                          ^^^
  stack:             [{:}, {}]

Step 43:
  program counter:   1350
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                          ^
  stack:             [{:}, {}, 0]

Step 44:
  program counter:   1351
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (0, {}); insert first value into the second; push result ({ 0 })
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                          ^^^
  stack:             [{:}, { 0 }]

Step 45:
  program counter:   1352
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                            ^
  stack:             [{:}, { 0 }, 1]

Step 46:
  program counter:   1353
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (1, { 0 }); insert first value into the second; push result ({ 0, 1 })
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                          ^^^
  stack:             [{:}, { 0, 1 }]

Step 47:
  program counter:   1354
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^
  stack:             [{:}, { 0, 1 }, 0]

Step 48:
  program counter:   1355
  hvm code:          Cut(tid)
  explanation:       pop index (0) and value ({ 0, 1 }); assign value (0) to tid; push new index (1) and True
  start expression:  line=14 column=21
  end expression:    line=14 column=24
  method variables:  { $accu1118: {}, tid: 0 }
  stack:             [{:}, { 0, 1 }, 1, True]

Step 49:
  program counter:   1356
  hvm code:          JumpCond False 1369
  explanation:       pop value (True), compare to False, and jump to 1369 if the same
  start expression:  line=14 column=21
  end expression:    line=14 column=24
  stack:             [{:}, { 0, 1 }, 1]

Step 50:
  program counter:   1357
  hvm code:          LoadVar $accu1118
  explanation:       push value ({}) of variable "$accu1118"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}]

Step 51:
  program counter:   1358
  hvm code:          DelVar $accu1118
  explanation:       delete method variable $accu1118
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { tid: 0 }

Step 52:
  program counter:   1359
  hvm code:          Push PC(1268)
  explanation:       push program counter constant 1268 (%+)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268)]

Step 53:
  program counter:   1360
  hvm code:          Push ?PC(1322)
  explanation:       push constant ?PC(1322)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                            ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1322)]

Step 54:
  program counter:   1361
  hvm code:          LoadVar tid
  explanation:       push value (0) of variable "tid"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                        ^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1322), 0]

Step 55:
  program counter:   1362
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=14 column=44
  end expression:    line=14 column=46
  method variables:  { }

Step 56:
  program counter:   1363
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(1322)); push result (?PC(1322)[0])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                            ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1322)[0]]

Step 57:
  program counter:   1364
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?PC(1322)[0], PC(1268)); push result (?PC(1268)[?PC(1322)[0]])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, ?PC(1268)[?PC(1322)[0]]]

Step 58:
  program counter:   1365
  hvm code:          Load
  explanation:       pop an argument (?PC(1322)[0]) and call method (1268: "fork")
  start expression:  line=14 column=21
  end expression:    line=14 column=48
  call trace:        main() --> fork(?PC(1322)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, ?PC(1322)[0]]

Step 59:
  program counter:   1268
  hvm code:          Frame fork(closure)
  explanation:       pop argument (?PC(1322)[0]), assign to closure, and run method "fork"
  module:            fork
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}]

Step 60:
  program counter:   1269
  hvm code:          Push PC(6)
  explanation:       push program counter constant 6 (%+)
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6)]

Step 61:
  program counter:   1270
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}]

Step 62:
  program counter:   1271
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema"]

Step 63:
  program counter:   1272
  hvm code:          Push PC(956)
  explanation:       push program counter constant 956 (%+)
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", PC(956)]

Step 64:
  program counter:   1273
  hvm code:          Push True
  explanation:       push constant True
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", PC(956), True]

Step 65:
  program counter:   1274
  hvm code:          2-ary Closure
  explanation:       pop 2 values (True, PC(956)); push result (?PC(956)[True])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", ?PC(956)[True]]

Step 66:
  program counter:   1275
  hvm code:          Load
  explanation:       pop an argument (True) and call method (956: "BinSema")
  start expression:  line=8 column=36
  end expression:    line=8 column=54
  call trace:        main() --> fork(?PC(1322)[0]) --> BinSema(True)
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, True]

Step 67:
  program counter:   956
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (True), assign to initial, and run method "BinSema"
  module:            synch
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: True }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }]

Step 68:
  program counter:   957
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 69:
  program counter:   958
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 70:
  program counter:   959
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True]

Step 71:
  program counter:   960
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True, {}]

Step 72:
  program counter:   961
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True, {}, False]

Step 73:
  program counter:   962
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True, { False }]

Step 74:
  program counter:   963
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True, { False }, True]

Step 75:
  program counter:   964
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True, { False, True }]

Step 76:
  program counter:   965
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, True); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True]

Step 77:
  program counter:   966
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }]

Step 78:
  program counter:   967
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 79:
  program counter:   968
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 80:
  program counter:   969
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }, True]

Step 81:
  program counter:   970
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 82:
  program counter:   971
  hvm code:          StoreVar sema
  explanation:       pop value (True) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: True }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[0] }]

Step 83:
  program counter:   972
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[0] }
  call trace:        main() --> fork(?PC(1322)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), {:}, "sema", True]

Step 84:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), { "sema": True }]

Step 85:
  program counter:   1277
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                         ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), { "sema": True }, "result"]

Step 86:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), { "sema": True }, "result", None]

Step 87:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "result", { "sema": True }); add key/value pair to dictionary; push result ({ "result": None, "sema": True })
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, PC(6), { "result": None, "sema": True }]

Step 88:
  program counter:   1280
  hvm code:          2-ary Closure
  explanation:       pop 2 values ({ "result": None, "sema": True }, PC(6)); push result (?PC(6)[{ "result": None, "sema": True }])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(6)[{ "result": None, "sema": True }]]

Step 89:
  program counter:   1281
  hvm code:          Load
  explanation:       pop an argument ({ "result": None, "sema": True }) and call method (6: "malloc")
  start expression:  line=8 column=14
  end expression:    line=8 column=72
  call trace:        main() --> fork(?PC(1322)[0]) --> malloc({ "result": None, "sema": True })
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "result": None, "sema": True }]

Step 90:
  program counter:   6
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "result": None, "sema": True }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "result": None, "sema": True } }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }]

Step 91:
  program counter:   7
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        main() --> fork(?PC(1322)[0]) --> malloc({ "result": None, "sema": True })

Step 92:
  program counter:   8
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool]

Step 93:
  program counter:   9
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool, 0]

Step 94:
  program counter:   10
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool[0]]

Step 95:
  program counter:   11
  hvm code:          LoadVar v
  explanation:       push value ({ "result": None, "sema": True }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool[0], { "result": None, "sema": True }]

Step 96:
  program counter:   12
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 97:
  program counter:   13
  hvm code:          Store
  explanation:       pop value ({ "result": None, "sema": True }) and address (?alloc$pool[0]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { I: 10, alloc$next: 0, alloc$pool: [ { "result": None, "sema": True } ], counter: 0 }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }]

Step 98:
  program counter:   14
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool]

Step 99:
  program counter:   15
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool, 0]

Step 100:
  program counter:   16
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, ?alloc$pool[0]]

Step 101:
  program counter:   17
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }]

Step 102:
  program counter:   18
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, 0]

Step 103:
  program counter:   19
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, 0, 1]

Step 104:
  program counter:   20
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }, 1]

Step 105:
  program counter:   21
  hvm code:          Store alloc$next
  explanation:       pop value (1) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { I: 10, alloc$next: 1, alloc$pool: [ { "result": None, "sema": True } ], counter: 0 }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[0] }]

Step 106:
  program counter:   22
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 107:
  program counter:   23
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[0] }
  call trace:        main() --> fork(?PC(1322)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?alloc$pool[0]]

Step 108:
  program counter:   1282
  hvm code:          StoreVar handle
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"handle\"
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                     ^^^^^^^^
  method variables:  { closure: ?PC(1322)[0], handle: ?alloc$pool[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}]

Step 109:
  program counter:   1283
  hvm code:          Push ?PC(1250)
  explanation:       push constant ?PC(1250)
  start statement:   line=9 column=5
  end statement:     line=9 column=34
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250)]

Step 110:
  program counter:   1284
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250), []]

Step 111:
  program counter:   1285
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1322)[0]) of variable "closure"
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250), [], ?PC(1322)[0]]

Step 112:
  program counter:   1286
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=9 column=19
  end expression:    line=9 column=25
  method variables:  { handle: ?alloc$pool[0] }

Step 113:
  program counter:   1287
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?PC(1322)[0], []); insert first value into the second; push result ([?PC(1322)[0]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[0] ]]

Step 114:
  program counter:   1288
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  source code:       spawn _helper(closure, handle)
                                            ^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[0] ], ?alloc$pool[0]]

Step 115:
  program counter:   1289
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?alloc$pool[0], [?PC(1322)[0]]); insert first value into the second; push result ([?PC(1322)[0], ?alloc$pool[0]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[0], ?alloc$pool[0] ]]

Step 116:
  program counter:   1290
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([?PC(1322)[0], ?alloc$pool[0]], ?PC(1250)); push result (?PC(1250)[[?PC(1322)[0], ?alloc$pool[0]]])
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250)[[ ?PC(1322)[0], ?alloc$pool[0] ]]]

Step 117:
  program counter:   1291
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn _helper(closure, handle)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}, ?PC(1250)[[ ?PC(1322)[0], ?alloc$pool[0] ]], {:}]

Step 118:
  program counter:   1292
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([?PC(1322)[0], ?alloc$pool[0]]), and pc (1250: "_helper"), and spawn thread
  start expression:  line=9 column=5
  end expression:    line=9 column=34
  stack:             [{:}, { 0, 1 }, 1, {}, [], 21842, {:}]

Step 119:
  program counter:   1293
  hvm code:          ReturnOp(handle)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        main()
  stack:             [{:}, { 0, 1 }, 1, {}, ?alloc$pool[0]]

Step 120:
  program counter:   1366
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (?alloc$pool[0], {}); insert first value into the second; push result ({ ?alloc$pool[0] })
  module:            __main__
  start statement:   line=14 column=9
  end statement:     line=14 column=67
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, { ?alloc$pool[0] }]

Step 121:
  program counter:   1367
  hvm code:          StoreVar $accu1118
  explanation:       pop value ({ ?alloc$pool[0] }) and store locally in variable \"$accu1118\"
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { $accu1118: { ?alloc$pool[0] } }
  stack:             [{:}, { 0, 1 }, 1]

Step 122:
  program counter:   1368
  hvm code:          Jump 1355
  explanation:       set program counter to 1355
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                             ^

Step 123:
  program counter:   1355
  hvm code:          Cut(tid)
  explanation:       pop index (1) and value ({ 0, 1 }); assign value (1) to tid; push new index (2) and True
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^
  method variables:  { $accu1118: { ?alloc$pool[0] }, tid: 1 }
  stack:             [{:}, { 0, 1 }, 2, True]

Step 124:
  program counter:   1356
  hvm code:          JumpCond False 1369
  explanation:       pop value (True), compare to False, and jump to 1369 if the same
  start expression:  line=14 column=21
  end expression:    line=14 column=24
  stack:             [{:}, { 0, 1 }, 2]

Step 125:
  program counter:   1357
  hvm code:          LoadVar $accu1118
  explanation:       push value ({ ?alloc$pool[0] }) of variable "$accu1118"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }]

Step 126:
  program counter:   1358
  hvm code:          DelVar $accu1118
  explanation:       delete method variable $accu1118
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { tid: 1 }

Step 127:
  program counter:   1359
  hvm code:          Push PC(1268)
  explanation:       push program counter constant 1268 (%+)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268)]

Step 128:
  program counter:   1360
  hvm code:          Push ?PC(1322)
  explanation:       push constant ?PC(1322)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                            ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1322)]

Step 129:
  program counter:   1361
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                        ^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1322), 1]

Step 130:
  program counter:   1362
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=14 column=44
  end expression:    line=14 column=46
  method variables:  { }

Step 131:
  program counter:   1363
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1322)); push result (?PC(1322)[1])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                            ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1322)[1]]

Step 132:
  program counter:   1364
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?PC(1322)[1], PC(1268)); push result (?PC(1268)[?PC(1322)[1]])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, ?PC(1268)[?PC(1322)[1]]]

Step 133:
  program counter:   1365
  hvm code:          Load
  explanation:       pop an argument (?PC(1322)[1]) and call method (1268: "fork")
  start expression:  line=14 column=21
  end expression:    line=14 column=48
  call trace:        main() --> fork(?PC(1322)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, ?PC(1322)[1]]

Step 134:
  program counter:   1268
  hvm code:          Frame fork(closure)
  explanation:       pop argument (?PC(1322)[1]), assign to closure, and run method "fork"
  module:            fork
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}]

Step 135:
  program counter:   1269
  hvm code:          Push PC(6)
  explanation:       push program counter constant 6 (%+)
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6)]

Step 136:
  program counter:   1270
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}]

Step 137:
  program counter:   1271
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema"]

Step 138:
  program counter:   1272
  hvm code:          Push PC(956)
  explanation:       push program counter constant 956 (%+)
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", PC(956)]

Step 139:
  program counter:   1273
  hvm code:          Push True
  explanation:       push constant True
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", PC(956), True]

Step 140:
  program counter:   1274
  hvm code:          2-ary Closure
  explanation:       pop 2 values (True, PC(956)); push result (?PC(956)[True])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", ?PC(956)[True]]

Step 141:
  program counter:   1275
  hvm code:          Load
  explanation:       pop an argument (True) and call method (956: "BinSema")
  start expression:  line=8 column=36
  end expression:    line=8 column=54
  call trace:        main() --> fork(?PC(1322)[1]) --> BinSema(True)
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, True]

Step 142:
  program counter:   956
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (True), assign to initial, and run method "BinSema"
  module:            synch
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: True }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }]

Step 143:
  program counter:   957
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 144:
  program counter:   958
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 145:
  program counter:   959
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True]

Step 146:
  program counter:   960
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True, {}]

Step 147:
  program counter:   961
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True, {}, False]

Step 148:
  program counter:   962
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True, { False }]

Step 149:
  program counter:   963
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True, { False }, True]

Step 150:
  program counter:   964
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True, { False, True }]

Step 151:
  program counter:   965
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, True); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True]

Step 152:
  program counter:   966
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }]

Step 153:
  program counter:   967
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 154:
  program counter:   968
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 155:
  program counter:   969
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }, True]

Step 156:
  program counter:   970
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 157:
  program counter:   971
  hvm code:          StoreVar sema
  explanation:       pop value (True) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: True }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1322)[1] }]

Step 158:
  program counter:   972
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[1] }
  call trace:        main() --> fork(?PC(1322)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), {:}, "sema", True]

Step 159:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), { "sema": True }]

Step 160:
  program counter:   1277
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                         ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), { "sema": True }, "result"]

Step 161:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), { "sema": True }, "result", None]

Step 162:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "result", { "sema": True }); add key/value pair to dictionary; push result ({ "result": None, "sema": True })
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, PC(6), { "result": None, "sema": True }]

Step 163:
  program counter:   1280
  hvm code:          2-ary Closure
  explanation:       pop 2 values ({ "result": None, "sema": True }, PC(6)); push result (?PC(6)[{ "result": None, "sema": True }])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(6)[{ "result": None, "sema": True }]]

Step 164:
  program counter:   1281
  hvm code:          Load
  explanation:       pop an argument ({ "result": None, "sema": True }) and call method (6: "malloc")
  start expression:  line=8 column=14
  end expression:    line=8 column=72
  call trace:        main() --> fork(?PC(1322)[1]) --> malloc({ "result": None, "sema": True })
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "result": None, "sema": True }]

Step 165:
  program counter:   6
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "result": None, "sema": True }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "result": None, "sema": True } }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }]

Step 166:
  program counter:   7
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        main() --> fork(?PC(1322)[1]) --> malloc({ "result": None, "sema": True })

Step 167:
  program counter:   8
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool]

Step 168:
  program counter:   9
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool, 1]

Step 169:
  program counter:   10
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?alloc$pool); push result (?alloc$pool[1])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool[1]]

Step 170:
  program counter:   11
  hvm code:          LoadVar v
  explanation:       push value ({ "result": None, "sema": True }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool[1], { "result": None, "sema": True }]

Step 171:
  program counter:   12
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 172:
  program counter:   13
  hvm code:          Store
  explanation:       pop value ({ "result": None, "sema": True }) and address (?alloc$pool[1]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { I: 10, alloc$next: 1, alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ], counter: 0 }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }]

Step 173:
  program counter:   14
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool]

Step 174:
  program counter:   15
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool, 1]

Step 175:
  program counter:   16
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?alloc$pool); push result (?alloc$pool[1])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, ?alloc$pool[1]]

Step 176:
  program counter:   17
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[1]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }]

Step 177:
  program counter:   18
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, 1]

Step 178:
  program counter:   19
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, 1, 1]

Step 179:
  program counter:   20
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }, 2]

Step 180:
  program counter:   21
  hvm code:          Store alloc$next
  explanation:       pop value (2) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { I: 10, alloc$next: 2, alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ], counter: 0 }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, [], 20498, { "closure": ?PC(1322)[1] }]

Step 181:
  program counter:   22
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 182:
  program counter:   23
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[1] }
  call trace:        main() --> fork(?PC(1322)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?alloc$pool[1]]

Step 183:
  program counter:   1282
  hvm code:          StoreVar handle
  explanation:       pop value (?alloc$pool[1]) and store locally in variable \"handle\"
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                     ^^^^^^^^
  method variables:  { closure: ?PC(1322)[1], handle: ?alloc$pool[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}]

Step 184:
  program counter:   1283
  hvm code:          Push ?PC(1250)
  explanation:       push constant ?PC(1250)
  start statement:   line=9 column=5
  end statement:     line=9 column=34
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250)]

Step 185:
  program counter:   1284
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250), []]

Step 186:
  program counter:   1285
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1322)[1]) of variable "closure"
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250), [], ?PC(1322)[1]]

Step 187:
  program counter:   1286
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=9 column=19
  end expression:    line=9 column=25
  method variables:  { handle: ?alloc$pool[1] }

Step 188:
  program counter:   1287
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?PC(1322)[1], []); insert first value into the second; push result ([?PC(1322)[1]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[1] ]]

Step 189:
  program counter:   1288
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[1]) of variable "handle"
  source code:       spawn _helper(closure, handle)
                                            ^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[1] ], ?alloc$pool[1]]

Step 190:
  program counter:   1289
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?alloc$pool[1], [?PC(1322)[1]]); insert first value into the second; push result ([?PC(1322)[1], ?alloc$pool[1]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250), [ ?PC(1322)[1], ?alloc$pool[1] ]]

Step 191:
  program counter:   1290
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([?PC(1322)[1], ?alloc$pool[1]], ?PC(1250)); push result (?PC(1250)[[?PC(1322)[1], ?alloc$pool[1]]])
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250)[[ ?PC(1322)[1], ?alloc$pool[1] ]]]

Step 192:
  program counter:   1291
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn _helper(closure, handle)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}, ?PC(1250)[[ ?PC(1322)[1], ?alloc$pool[1] ]], {:}]

Step 193:
  program counter:   1292
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([?PC(1322)[1], ?alloc$pool[1]]), and pc (1250: "_helper"), and spawn thread
  start expression:  line=9 column=5
  end expression:    line=9 column=34
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 21842, {:}]

Step 194:
  program counter:   1293
  hvm code:          ReturnOp(handle)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        main()
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, ?alloc$pool[1]]

Step 195:
  program counter:   1366
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (?alloc$pool[1], { ?alloc$pool[0] }); insert first value into the second; push result ({ ?alloc$pool[0], ?alloc$pool[1] })
  module:            __main__
  start statement:   line=14 column=9
  end statement:     line=14 column=67
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 196:
  program counter:   1367
  hvm code:          StoreVar $accu1118
  explanation:       pop value ({ ?alloc$pool[0], ?alloc$pool[1] }) and store locally in variable \"$accu1118\"
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { $accu1118: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}, { 0, 1 }, 2]

Step 197:
  program counter:   1368
  hvm code:          Jump 1355
  explanation:       set program counter to 1355
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                                                             ^

Step 198:
  program counter:   1355
  hvm code:          Cut(tid)
  explanation:       pop index (2) and value ({ 0, 1 }); out of range -> push False
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^
  stack:             [{:}, False]

Step 199:
  program counter:   1356
  hvm code:          JumpCond False 1369
  explanation:       pop value (False), compare to False, and jump to 1369 if the same
  start expression:  line=14 column=21
  end expression:    line=14 column=24
  stack:             [{:}]

Step 200:
  program counter:   1369
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 201:
  program counter:   1370
  hvm code:          LoadVar $accu1118
  explanation:       push value ({ ?alloc$pool[0], ?alloc$pool[1] }) of variable "$accu1118"
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 202:
  program counter:   1371
  hvm code:          DelVar $accu1118
  explanation:       delete method variable $accu1118
  start expression:  line=14 column=21
  end expression:    line=14 column=65
  method variables:  { }

Step 203:
  program counter:   1372
  hvm code:          StoreVar tids
  explanation:       pop value ({ ?alloc$pool[0], ?alloc$pool[1] }) and store locally in variable \"tids\"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1} }:
                     ^^^^^^^^^^
  method variables:  { tids: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}]

Step 204:
  program counter:   1373
  hvm code:          Push {}
  explanation:       initialize accumulator for set comprehension: push constant {}
  start statement:   line=15 column=17
  end statement:     line=15 column=48
  source code:       {fork.join(tid) for tid in tids}; 
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 205:
  program counter:   1374
  hvm code:          StoreVar $accu1140
  explanation:       pop value ({}) and store locally in variable \"$accu1140\"
  start expression:  line=15 column=18
  end expression:    line=15 column=47
  method variables:  { $accu1140: {}, tids: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}]

Step 206:
  program counter:   1375
  hvm code:          LoadVar tids
  explanation:       push value ({ ?alloc$pool[0], ?alloc$pool[1] }) of variable "tids"
  source code:       {fork.join(tid) for tid in tids}; 
                                                ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 207:
  program counter:   1376
  hvm code:          DelVar tids
  explanation:       delete method variable tids
  start expression:  line=15 column=44
  end expression:    line=15 column=47
  method variables:  { $accu1140: {} }

Step 208:
  program counter:   1377
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       {fork.join(tid) for tid in tids}; 
                      ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 0]

Step 209:
  program counter:   1378
  hvm code:          Cut(tid)
  explanation:       pop index (0) and value ({ ?alloc$pool[0], ?alloc$pool[1] }); assign value (?alloc$pool[0]) to tid; push new index (1) and True
  start expression:  line=15 column=18
  end expression:    line=15 column=21
  method variables:  { $accu1140: {}, tid: ?alloc$pool[0] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, True]

Step 210:
  program counter:   1379
  hvm code:          JumpCond False 1390
  explanation:       pop value (True), compare to False, and jump to 1390 if the same
  start expression:  line=15 column=18
  end expression:    line=15 column=21
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1]

Step 211:
  program counter:   1380
  hvm code:          LoadVar $accu1140
  explanation:       push value ({}) of variable "$accu1140"
  source code:       {fork.join(tid) for tid in tids}; 
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}]

Step 212:
  program counter:   1381
  hvm code:          DelVar $accu1140
  explanation:       delete method variable $accu1140
  start expression:  line=15 column=18
  end expression:    line=15 column=47
  method variables:  { tid: ?alloc$pool[0] }

Step 213:
  program counter:   1382
  hvm code:          Push PC(1296)
  explanation:       push program counter constant 1296 (%+)
  source code:       {fork.join(tid) for tid in tids}; 
                      ^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, PC(1296)]

Step 214:
  program counter:   1383
  hvm code:          LoadVar tid
  explanation:       push value (?alloc$pool[0]) of variable "tid"
  source code:       {fork.join(tid) for tid in tids}; 
                                ^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, PC(1296), ?alloc$pool[0]]

Step 215:
  program counter:   1384
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=15 column=28
  end expression:    line=15 column=30
  method variables:  { }

Step 216:
  program counter:   1385
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0], PC(1296)); push result (?PC(1296)[?alloc$pool[0]])
  source code:       {fork.join(tid) for tid in tids}; 
                      ^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, ?PC(1296)[?alloc$pool[0]]]

Step 217:
  program counter:   1386
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]) and call method (1296: "join")
  start expression:  line=15 column=18
  end expression:    line=15 column=31
  call trace:        main() --> join(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, ?alloc$pool[0]]

Step 218:
  program counter:   1296
  hvm code:          Frame join(meta)
  explanation:       pop argument (?alloc$pool[0]), assign to meta, and run method "join"
  module:            fork
  start statement:   line=11 column=1
  end statement:     line=11 column=30
  source code:       def join(meta) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { meta: ?alloc$pool[0] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}]

Step 219:
  program counter:   1297
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=12 column=5
  end statement:     line=12 column=30
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^

Step 220:
  program counter:   1298
  hvm code:          Push PC(998)
  explanation:       push program counter constant 998 (%+)
  start expression:  line=12 column=5
  end expression:    line=12 column=17
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, PC(998)]

Step 221:
  program counter:   1299
  hvm code:          LoadVar meta
  explanation:       push value (?alloc$pool[0]) of variable "meta"
  source code:       synch.acquire(?meta->sema)
                                    ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, PC(998), ?alloc$pool[0]]

Step 222:
  program counter:   1300
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       synch.acquire(?meta->sema)
                                          ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, PC(998), ?alloc$pool[0], "sema"]

Step 223:
  program counter:   1301
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("sema", ?alloc$pool[0]); push result (?alloc$pool[0]["sema"])
  source code:       synch.acquire(?meta->sema)
                                    ^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, PC(998), ?alloc$pool[0]["sema"]]

Step 224:
  program counter:   1302
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0]["sema"], PC(998)); push result (?PC(998)[?alloc$pool[0]["sema"]])
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, ?PC(998)[?alloc$pool[0]["sema"]]]

Step 225:
  program counter:   1303
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]["sema"]) and call method (998: "acquire")
  start expression:  line=12 column=5
  end expression:    line=12 column=30
  call trace:        main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, [], 20850, ?alloc$pool[0]["sema"]]

Step 226:
  program counter:   998
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?alloc$pool[0]["sema"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?alloc$pool[0]["sema"] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 22178, {:}, [], 20850, { "meta": ?alloc$pool[0] }]

================================================
Running thread T2: _helper(?PC(1322)[0], ?alloc$pool[0])
mode:  runnable
stack: ['[ ?PC(1322)[0], ?alloc$pool[0] ]']
other threads:
  T0: pc=1402 terminated atomic __init__()
  T1: pc=999 blocked main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T3: pc=1250 runnable _helper(?PC(1322)[1], ?alloc$pool[1])
    about to run method _helper with argument [ ?PC(1322)[1], ?alloc$pool[1] ]
shared variables:
  I: 10
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ]
  counter: 0
state id: 6
================================================

Step 227:
  program counter:   1250
  hvm code:          Frame _helper(closure, handle)
  explanation:       pop argument ([?PC(1322)[0], ?alloc$pool[0]]), assign to (closure, handle), and run method "_helper"
  module:            fork
  start statement:   line=3 column=1
  end statement:     line=3 column=29
  source code:       def _helper(closure, handle):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[0], handle: ?alloc$pool[0] }
  call trace:        _helper(?PC(1322)[0], ?alloc$pool[0])
  stack:             [{:}]

Step 228:
  program counter:   1251
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  start statement:   line=4 column=5
  end statement:     line=4 column=29
  source code:       handle->result = !closure
                     ^^^^^^
  stack:             [{:}, ?alloc$pool[0]]

Step 229:
  program counter:   1252
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle->result = !closure
                             ^^^^^^
  stack:             [{:}, ?alloc$pool[0], "result"]

Step 230:
  program counter:   1253
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("result", ?alloc$pool[0]); push result (?alloc$pool[0]["result"])
  source code:       handle->result = !closure
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"]]

Step 231:
  program counter:   1254
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1322)[0]) of variable "closure"
  source code:       handle->result = !closure
                                       ^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], ?PC(1322)[0]]

Step 232:
  program counter:   1255
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=4 column=23
  end expression:    line=4 column=29
  method variables:  { handle: ?alloc$pool[0] }

Step 233:
  program counter:   1256
  hvm code:          Load
  explanation:       pop an argument (0) and call method (1322: "incrementer")
  source code:       handle->result = !closure
                                      ^^^^^^^^
  call trace:        _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, 0]

Step 234:
  program counter:   1322
  hvm code:          Frame incrementer(id)
  explanation:       pop argument (0), assign to id, and run method "incrementer"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=19
  source code:       def incrementer id:
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { id: 0 }
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }]

Step 235:
  program counter:   1323
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=6 column=9
  end statement:     line=6 column=23
  source code:       for j in {0..I}: 
                               ^
  method variables:  { }

Step 236:
  program counter:   1324
  hvm code:          Push 0
  explanation:       push constant 0
  start expression:  line=6 column=19
  end expression:    line=6 column=19
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, 0]

Step 237:
  program counter:   1325
  hvm code:          Load I
  explanation:       push value (10) of variable I
  source code:       for j in {0..I}: 
                                  ^
  call trace:        _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, 0, 10]

Step 238:
  program counter:   1326
  hvm code:          2-ary ..
  explanation:       pop 2 values (10, 0); range of integers; push result ({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
  source code:       for j in {0..I}: 
                               ^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }]

Step 239:
  program counter:   1327
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for j in {0..I}: 
                     ^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 0]

Step 240:
  program counter:   1328
  hvm code:          Cut(j)
  explanation:       pop index (0) and value ({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); assign value (0) to j; push new index (1) and True
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  method variables:  { j: 0 }
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, True]

Step 241:
  program counter:   1329
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  method variables:  { }

Step 242:
  program counter:   1330
  hvm code:          JumpCond False 1344
  explanation:       pop value (True), compare to False, and jump to 1344 if the same
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1]

Step 243:
  program counter:   1331
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=17
  end statement:     line=7 column=27
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)

Step 244:
  program counter:   1332
  hvm code:          Push "entrei"
  explanation:       push constant "entrei"
  start statement:   line=8 column=25
  end statement:     line=8 column=39
  source code:       print("entrei");
                           ^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, "entrei"]

Step 245:
  program counter:   1333
  hvm code:          Print
  explanation:       pop value ("entrei") and add to print log
  source code:       print("entrei");
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1]

Step 246:
  program counter:   1334
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=17
  end statement:     line=7 column=27
  source code:       atomically:
                     ^^^^^^^^^^^

Step 247:
  program counter:   1335
  hvm code:          Load counter
  explanation:       push value (0) of variable counter
  start statement:   line=9 column=17
  end statement:     line=9 column=28
  source code:       counter += 1;
                     ^^^^^^^^^^^^
  call trace:        _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, 0]

Step 248:
  program counter:   1336
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       counter += 1;
                                ^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, 0, 1]

Step 249:
  program counter:   1337
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       counter += 1;
                     ^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, 1]

================================================
Running thread T3: _helper(?PC(1322)[1], ?alloc$pool[1])
mode:  runnable
stack: ['[ ?PC(1322)[1], ?alloc$pool[1] ]']
other threads:
  T0: pc=1402 terminated atomic __init__()
  T1: pc=999 blocked main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T2: pc=1338 runnable _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)
    about to store 1 into variable counter
shared variables:
  I: 10
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ]
  counter: 0
state id: 24
================================================

Step 250:
  program counter:   1250
  hvm code:          Frame _helper(closure, handle)
  explanation:       pop argument ([?PC(1322)[1], ?alloc$pool[1]]), assign to (closure, handle), and run method "_helper"
  module:            fork
  start statement:   line=3 column=1
  end statement:     line=3 column=29
  source code:       def _helper(closure, handle):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1322)[1], handle: ?alloc$pool[1] }
  call trace:        _helper(?PC(1322)[1], ?alloc$pool[1])
  stack:             [{:}]

Step 251:
  program counter:   1251
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[1]) of variable "handle"
  start statement:   line=4 column=5
  end statement:     line=4 column=29
  source code:       handle->result = !closure
                     ^^^^^^
  stack:             [{:}, ?alloc$pool[1]]

Step 252:
  program counter:   1252
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle->result = !closure
                             ^^^^^^
  stack:             [{:}, ?alloc$pool[1], "result"]

Step 253:
  program counter:   1253
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("result", ?alloc$pool[1]); push result (?alloc$pool[1]["result"])
  source code:       handle->result = !closure
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"]]

Step 254:
  program counter:   1254
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1322)[1]) of variable "closure"
  source code:       handle->result = !closure
                                       ^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], ?PC(1322)[1]]

Step 255:
  program counter:   1255
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=4 column=23
  end expression:    line=4 column=29
  method variables:  { handle: ?alloc$pool[1] }

Step 256:
  program counter:   1256
  hvm code:          Load
  explanation:       pop an argument (1) and call method (1322: "incrementer")
  source code:       handle->result = !closure
                                      ^^^^^^^^
  call trace:        _helper(?PC(1322)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, 1]

Step 257:
  program counter:   1322
  hvm code:          Frame incrementer(id)
  explanation:       pop argument (1), assign to id, and run method "incrementer"
  module:            __main__
  start statement:   line=5 column=1
  end statement:     line=5 column=19
  source code:       def incrementer id:
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { id: 1 }
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 258:
  program counter:   1323
  hvm code:          DelVar id
  explanation:       delete method variable id
  start statement:   line=6 column=9
  end statement:     line=6 column=23
  source code:       for j in {0..I}: 
                               ^
  method variables:  { }

Step 259:
  program counter:   1324
  hvm code:          Push 0
  explanation:       push constant 0
  start expression:  line=6 column=19
  end expression:    line=6 column=19
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0]

Step 260:
  program counter:   1325
  hvm code:          Load I
  explanation:       push value (10) of variable I
  source code:       for j in {0..I}: 
                                  ^
  call trace:        _helper(?PC(1322)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0, 10]

Step 261:
  program counter:   1326
  hvm code:          2-ary ..
  explanation:       pop 2 values (10, 0); range of integers; push result ({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
  source code:       for j in {0..I}: 
                               ^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }]

Step 262:
  program counter:   1327
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for j in {0..I}: 
                     ^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 0]

Step 263:
  program counter:   1328
  hvm code:          Cut(j)
  explanation:       pop index (0) and value ({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }); assign value (0) to j; push new index (1) and True
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  method variables:  { j: 0 }
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, True]

Step 264:
  program counter:   1329
  hvm code:          DelVar j
  explanation:       delete method variable j
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  method variables:  { }

Step 265:
  program counter:   1330
  hvm code:          JumpCond False 1344
  explanation:       pop value (True), compare to False, and jump to 1344 if the same
  start expression:  line=6 column=9
  end expression:    line=6 column=11
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1]

Step 266:
  program counter:   1331
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=17
  end statement:     line=7 column=27
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        _helper(?PC(1322)[1], ?alloc$pool[1]) --> incrementer(1)

Step 267:
  program counter:   1332
  hvm code:          Push "entrei"
  explanation:       push constant "entrei"
  start statement:   line=8 column=25
  end statement:     line=8 column=39
  source code:       print("entrei");
                           ^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1, "entrei"]

Step 268:
  program counter:   1333
  hvm code:          Print
  explanation:       pop value ("entrei") and add to print log
  source code:       print("entrei");
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 1]

Step 269:
  program counter:   1334
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=17
  end statement:     line=7 column=27
  source code:       atomically:
                     ^^^^^^^^^^^

================================================
Final state
================================================
Threads:
  T0: pc=1402 terminated atomic __init__()
  T1: pc=999 blocked main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T2: pc=1338 runnable _helper(?PC(1322)[0], ?alloc$pool[0]) --> incrementer(0)
    about to store 1 into variable counter
  T3: pc=1335 runnable _helper(?PC(1322)[1], ?alloc$pool[1]) --> incrementer(1)
    about to load variable counter
Variables:
  I: 10
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ]
  counter: 0

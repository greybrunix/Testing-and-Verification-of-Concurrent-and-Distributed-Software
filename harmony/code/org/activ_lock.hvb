Issue: Non-terminating state

Modules:
  alloc: /home/bdg/virtual/lib/python3.11/site-packages/harmony_model_checker/modules/alloc.hny
  bag: /home/bdg/virtual/lib/python3.11/site-packages/harmony_model_checker/modules/bag.hny
  __main__: activ_lock.hny
  synch: /home/bdg/virtual/lib/python3.11/site-packages/harmony_model_checker/modules/synch.hny
  fork: /home/bdg/virtual/lib/python3.11/site-packages/harmony_model_checker/modules/fork.hny
  list: /home/bdg/virtual/lib/python3.11/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=31 column=7
  source code:       import fork
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push {:}
  explanation:       push constant {:}
  module:            alloc
  start statement:   line=1 column=1
  end statement:     line=1 column=10
  source code:       pool = {:}
                            ^^^
  stack:             [{:}, {:}]

Step 3:
  program counter:   2
  hvm code:          Store alloc$pool
  explanation:       pop value ({:}) and store into variable alloc$pool
  source code:       pool = {:}
                     ^^^^^^
  shared variables:  { alloc$pool: {:} }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=2 column=1
  end statement:     line=2 column=8
  source code:       next = 0
                            ^
  stack:             [{:}, 0]

Step 5:
  program counter:   4
  hvm code:          Store alloc$next
  explanation:       pop value (0) and store into variable alloc$next
  source code:       next = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 6:
  program counter:   5
  hvm code:          Jump 98
  explanation:       jump over method definition: set program counter to 98
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^

Step 7:
  program counter:   98
  hvm code:          Push PC(101)
  explanation:       push constant PC(101)
  module:            list
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(101)]

Step 8:
  program counter:   99
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (%+) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 9:
  program counter:   100
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 10:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(649)]

Step 11:
  program counter:   647
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (%+) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 12:
  program counter:   648
  hvm code:          Jump 668
  explanation:       jump over method definition: set program counter to 668
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 13:
  program counter:   668
  hvm code:          Push PC(671)
  explanation:       push constant PC(671)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(671)]

Step 14:
  program counter:   669
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (%+) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 15:
  program counter:   670
  hvm code:          Jump 690
  explanation:       jump over method definition: set program counter to 690
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 16:
  program counter:   690
  hvm code:          Push PC(693)
  explanation:       push constant PC(693)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(693)]

Step 17:
  program counter:   691
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (%+) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 18:
  program counter:   692
  hvm code:          Jump 709
  explanation:       jump over method definition: set program counter to 709
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 19:
  program counter:   709
  hvm code:          Push PC(712)
  explanation:       push constant PC(712)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(712)]

Step 20:
  program counter:   710
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (%+) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 21:
  program counter:   711
  hvm code:          Jump 737
  explanation:       jump over method definition: set program counter to 737
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 22:
  program counter:   737
  hvm code:          Push PC(740)
  explanation:       push constant PC(740)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(740)]

Step 23:
  program counter:   738
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (%+) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 24:
  program counter:   739
  hvm code:          Jump 766
  explanation:       jump over method definition: set program counter to 766
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 25:
  program counter:   766
  hvm code:          Push PC(769)
  explanation:       push constant PC(769)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(769)]

Step 26:
  program counter:   767
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (%+) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 27:
  program counter:   768
  hvm code:          Jump 1317
  explanation:       jump over method definition: set program counter to 1317
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 28:
  program counter:   1317
  hvm code:          Push 0
  explanation:       push constant 0
  module:            __main__
  start statement:   line=3 column=1
  end statement:     line=3 column=11
  source code:       counter = 0;
                               ^
  stack:             [{:}, 0]

Step 29:
  program counter:   1318
  hvm code:          Store counter
  explanation:       pop value (0) and store into variable counter
  source code:       counter = 0;
                     ^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, counter: 0 }
  stack:             [{:}]

Step 30:
  program counter:   1319
  hvm code:          Push ?wants
  explanation:       push constant ?wants
  start statement:   line=4 column=1
  end statement:     line=4 column=22
  source code:       sequential wants, turn
                                ^^^^^
  stack:             [{:}, ?wants]

Step 31:
  program counter:   1320
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential wants, turn
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 32:
  program counter:   1321
  hvm code:          Push ?turn
  explanation:       push constant ?turn
  source code:       sequential wants, turn
                                       ^^^^
  stack:             [{:}, ?turn]

Step 33:
  program counter:   1322
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential wants, turn
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 34:
  program counter:   1323
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=5 column=1
  end statement:     line=5 column=22
  source code:       wants = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, []]

Step 35:
  program counter:   1324
  hvm code:          Push False
  explanation:       push constant False
  source code:       wants = [False, False]
                              ^^^^^
  stack:             [{:}, [], False]

Step 36:
  program counter:   1325
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  source code:       wants = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False ]]

Step 37:
  program counter:   1326
  hvm code:          Push False
  explanation:       push constant False
  source code:       wants = [False, False]
                                     ^^^^^
  stack:             [{:}, [ False ], False]

Step 38:
  program counter:   1327
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, [False]); insert first value into the second; push result ([False, False])
  source code:       wants = [False, False]
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False, False ]]

Step 39:
  program counter:   1328
  hvm code:          Store wants
  explanation:       pop value ([False, False]) and store into variable wants
  source code:       wants = [False, False]
                     ^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, counter: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 40:
  program counter:   1329
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=6 column=1
  end statement:     line=6 column=8
  source code:       turn = 0
                            ^
  stack:             [{:}, 0]

Step 41:
  program counter:   1330
  hvm code:          Store turn
  explanation:       pop value (0) and store into variable turn
  source code:       turn = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, counter: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 42:
  program counter:   1331
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=7 column=1
  end statement:     line=7 column=9
  source code:       in_cs = 0;
                             ^
  stack:             [{:}, 0]

Step 43:
  program counter:   1332
  hvm code:          Store in_cs
  explanation:       pop value (0) and store into variable in_cs
  source code:       in_cs = 0;
                     ^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 44:
  program counter:   1333
  hvm code:          Jump 1344
  explanation:       jump over invariant definition: set program counter to 1344
  start statement:   line=8 column=1
  end statement:     line=8 column=24
  source code:       invariant in_cs in {0,1}
                     ^^^^^^^^^

Step 45:
  program counter:   1344
  hvm code:          Invariant 1334
  explanation:       test invariant
  source code:       invariant in_cs in {0,1}
                     ^^^^^^^^^^^^^^^^^^^^^^^^

Step 46:
  program counter:   1345
  hvm code:          Jump 1467
  explanation:       jump over method definition: set program counter to 1467
  start statement:   line=10 column=1
  end statement:     line=10 column=21
  source code:       def incrementer(tid):
                     ^^^

Step 47:
  program counter:   1467
  hvm code:          Push ?PC(1416)
  explanation:       push constant ?PC(1416)
  start statement:   line=30 column=1
  end statement:     line=30 column=12
  source code:       spawn main()
                           ^^^^
  stack:             [{:}, ?PC(1416)]

Step 48:
  program counter:   1468
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn main()
                               ^^
  stack:             [{:}, ?PC(1416), []]

Step 49:
  program counter:   1469
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([], ?PC(1416)); push result (?PC(1416)[[]])
  source code:       spawn main()
                           ^^^^^^
  stack:             [{:}, ?PC(1416)[[]]]

Step 50:
  program counter:   1470
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn main()
                     ^^^^^^^^^^^^
  stack:             [{:}, ?PC(1416)[[]], {:}]

Step 51:
  program counter:   1471
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([]), and pc (1416: "main"), and spawn thread
  start expression:  line=30 column=1
  end expression:    line=30 column=12
  stack:             [{:}]

Step 52:
  program counter:   1472
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=31 column=7
  source code:       import fork
  new mode:          terminated
  stack:             [None]

================================================
Running thread T1: main()
mode:  runnable
stack: ['[]']
other threads:
  T0: pc=1472 terminated atomic __init__()
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  counter: 0
  in_cs: 0
  turn: 0
  wants: [ False, False ]
state id: 2
================================================

Step 53:
  program counter:   1416
  hvm code:          Frame main()
  explanation:       pop argument () and run method "main"
  start statement:   line=26 column=1
  end statement:     line=26 column=11
  source code:       def main():
                     ^^^^^^^^^^^
  call trace:        main()
  stack:             [{:}]

Step 54:
  program counter:   1417
  hvm code:          Push {}
  explanation:       initialize accumulator for set comprehension: push constant {}
  start statement:   line=27 column=9
  end statement:     line=27 column=66
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 55:
  program counter:   1418
  hvm code:          StoreVar $accu1189
  explanation:       pop value ({}) and store locally in variable \"$accu1189\"
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { $accu1189: {} }
  stack:             [{:}]

Step 56:
  program counter:   1419
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                          ^^^
  stack:             [{:}, {}]

Step 57:
  program counter:   1420
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                          ^
  stack:             [{:}, {}, 0]

Step 58:
  program counter:   1421
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (0, {}); insert first value into the second; push result ({ 0 })
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                          ^^^
  stack:             [{:}, { 0 }]

Step 59:
  program counter:   1422
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                            ^
  stack:             [{:}, { 0 }, 1]

Step 60:
  program counter:   1423
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (1, { 0 }); insert first value into the second; push result ({ 0, 1 })
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                          ^^^
  stack:             [{:}, { 0, 1 }]

Step 61:
  program counter:   1424
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^
  stack:             [{:}, { 0, 1 }, 0]

Step 62:
  program counter:   1425
  hvm code:          Cut(tid)
  explanation:       pop index (0) and value ({ 0, 1 }); assign value (0) to tid; push new index (1) and True
  start expression:  line=27 column=21
  end expression:    line=27 column=24
  method variables:  { $accu1189: {}, tid: 0 }
  stack:             [{:}, { 0, 1 }, 1, True]

Step 63:
  program counter:   1426
  hvm code:          JumpCond False 1439
  explanation:       pop value (True), compare to False, and jump to 1439 if the same
  start expression:  line=27 column=21
  end expression:    line=27 column=24
  stack:             [{:}, { 0, 1 }, 1]

Step 64:
  program counter:   1427
  hvm code:          LoadVar $accu1189
  explanation:       push value ({}) of variable "$accu1189"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}]

Step 65:
  program counter:   1428
  hvm code:          DelVar $accu1189
  explanation:       delete method variable $accu1189
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { tid: 0 }

Step 66:
  program counter:   1429
  hvm code:          Push PC(1268)
  explanation:       push program counter constant 1268 (%+)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268)]

Step 67:
  program counter:   1430
  hvm code:          Push ?PC(1346)
  explanation:       push constant ?PC(1346)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                            ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1346)]

Step 68:
  program counter:   1431
  hvm code:          LoadVar tid
  explanation:       push value (0) of variable "tid"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                        ^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1346), 0]

Step 69:
  program counter:   1432
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=27 column=44
  end expression:    line=27 column=46
  method variables:  { }

Step 70:
  program counter:   1433
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(1346)); push result (?PC(1346)[0])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                            ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, PC(1268), ?PC(1346)[0]]

Step 71:
  program counter:   1434
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?PC(1346)[0], PC(1268)); push result (?PC(1268)[?PC(1346)[0]])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, ?PC(1268)[?PC(1346)[0]]]

Step 72:
  program counter:   1435
  hvm code:          Load
  explanation:       pop an argument (?PC(1346)[0]) and call method (1268: "fork")
  start expression:  line=27 column=21
  end expression:    line=27 column=48
  call trace:        main() --> fork(?PC(1346)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, ?PC(1346)[0]]

Step 73:
  program counter:   1268
  hvm code:          Frame fork(closure)
  explanation:       pop argument (?PC(1346)[0]), assign to closure, and run method "fork"
  module:            fork
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}]

Step 74:
  program counter:   1269
  hvm code:          Push PC(6)
  explanation:       push program counter constant 6 (%+)
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6)]

Step 75:
  program counter:   1270
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}]

Step 76:
  program counter:   1271
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema"]

Step 77:
  program counter:   1272
  hvm code:          Push PC(956)
  explanation:       push program counter constant 956 (%+)
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", PC(956)]

Step 78:
  program counter:   1273
  hvm code:          Push True
  explanation:       push constant True
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", PC(956), True]

Step 79:
  program counter:   1274
  hvm code:          2-ary Closure
  explanation:       pop 2 values (True, PC(956)); push result (?PC(956)[True])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", ?PC(956)[True]]

Step 80:
  program counter:   1275
  hvm code:          Load
  explanation:       pop an argument (True) and call method (956: "BinSema")
  start expression:  line=8 column=36
  end expression:    line=8 column=54
  call trace:        main() --> fork(?PC(1346)[0]) --> BinSema(True)
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, True]

Step 81:
  program counter:   956
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (True), assign to initial, and run method "BinSema"
  module:            synch
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: True }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }]

Step 82:
  program counter:   957
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 83:
  program counter:   958
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 84:
  program counter:   959
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True]

Step 85:
  program counter:   960
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True, {}]

Step 86:
  program counter:   961
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True, {}, False]

Step 87:
  program counter:   962
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True, { False }]

Step 88:
  program counter:   963
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True, { False }, True]

Step 89:
  program counter:   964
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True, { False, True }]

Step 90:
  program counter:   965
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, True); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True]

Step 91:
  program counter:   966
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }]

Step 92:
  program counter:   967
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 93:
  program counter:   968
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 94:
  program counter:   969
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }, True]

Step 95:
  program counter:   970
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 96:
  program counter:   971
  hvm code:          StoreVar sema
  explanation:       pop value (True) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: True }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[0] }]

Step 97:
  program counter:   972
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[0] }
  call trace:        main() --> fork(?PC(1346)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), {:}, "sema", True]

Step 98:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), { "sema": True }]

Step 99:
  program counter:   1277
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                         ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), { "sema": True }, "result"]

Step 100:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), { "sema": True }, "result", None]

Step 101:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "result", { "sema": True }); add key/value pair to dictionary; push result ({ "result": None, "sema": True })
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, PC(6), { "result": None, "sema": True }]

Step 102:
  program counter:   1280
  hvm code:          2-ary Closure
  explanation:       pop 2 values ({ "result": None, "sema": True }, PC(6)); push result (?PC(6)[{ "result": None, "sema": True }])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(6)[{ "result": None, "sema": True }]]

Step 103:
  program counter:   1281
  hvm code:          Load
  explanation:       pop an argument ({ "result": None, "sema": True }) and call method (6: "malloc")
  start expression:  line=8 column=14
  end expression:    line=8 column=72
  call trace:        main() --> fork(?PC(1346)[0]) --> malloc({ "result": None, "sema": True })
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "result": None, "sema": True }]

Step 104:
  program counter:   6
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "result": None, "sema": True }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "result": None, "sema": True } }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }]

Step 105:
  program counter:   7
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        main() --> fork(?PC(1346)[0]) --> malloc({ "result": None, "sema": True })

Step 106:
  program counter:   8
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool]

Step 107:
  program counter:   9
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool, 0]

Step 108:
  program counter:   10
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool[0]]

Step 109:
  program counter:   11
  hvm code:          LoadVar v
  explanation:       push value ({ "result": None, "sema": True }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool[0], { "result": None, "sema": True }]

Step 110:
  program counter:   12
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 111:
  program counter:   13
  hvm code:          Store
  explanation:       pop value ({ "result": None, "sema": True }) and address (?alloc$pool[0]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: [ { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }]

Step 112:
  program counter:   14
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool]

Step 113:
  program counter:   15
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool, 0]

Step 114:
  program counter:   16
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, ?alloc$pool[0]]

Step 115:
  program counter:   17
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }]

Step 116:
  program counter:   18
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, 0]

Step 117:
  program counter:   19
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, 0, 1]

Step 118:
  program counter:   20
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }, 1]

Step 119:
  program counter:   21
  hvm code:          Store alloc$next
  explanation:       pop value (1) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[0] }]

Step 120:
  program counter:   22
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 121:
  program counter:   23
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[0] }
  call trace:        main() --> fork(?PC(1346)[0])
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?alloc$pool[0]]

Step 122:
  program counter:   1282
  hvm code:          StoreVar handle
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"handle\"
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                     ^^^^^^^^
  method variables:  { closure: ?PC(1346)[0], handle: ?alloc$pool[0] }
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}]

Step 123:
  program counter:   1283
  hvm code:          Push ?PC(1250)
  explanation:       push constant ?PC(1250)
  start statement:   line=9 column=5
  end statement:     line=9 column=34
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250)]

Step 124:
  program counter:   1284
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250), []]

Step 125:
  program counter:   1285
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1346)[0]) of variable "closure"
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250), [], ?PC(1346)[0]]

Step 126:
  program counter:   1286
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=9 column=19
  end expression:    line=9 column=25
  method variables:  { handle: ?alloc$pool[0] }

Step 127:
  program counter:   1287
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?PC(1346)[0], []); insert first value into the second; push result ([?PC(1346)[0]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[0] ]]

Step 128:
  program counter:   1288
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  source code:       spawn _helper(closure, handle)
                                            ^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[0] ], ?alloc$pool[0]]

Step 129:
  program counter:   1289
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?alloc$pool[0], [?PC(1346)[0]]); insert first value into the second; push result ([?PC(1346)[0], ?alloc$pool[0]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[0], ?alloc$pool[0] ]]

Step 130:
  program counter:   1290
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([?PC(1346)[0], ?alloc$pool[0]], ?PC(1250)); push result (?PC(1250)[[?PC(1346)[0], ?alloc$pool[0]]])
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250)[[ ?PC(1346)[0], ?alloc$pool[0] ]]]

Step 131:
  program counter:   1291
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn _helper(closure, handle)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}, ?PC(1250)[[ ?PC(1346)[0], ?alloc$pool[0] ]], {:}]

Step 132:
  program counter:   1292
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([?PC(1346)[0], ?alloc$pool[0]]), and pc (1250: "_helper"), and spawn thread
  start expression:  line=9 column=5
  end expression:    line=9 column=34
  stack:             [{:}, { 0, 1 }, 1, {}, [], 22962, {:}]

Step 133:
  program counter:   1293
  hvm code:          ReturnOp(handle)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        main()
  stack:             [{:}, { 0, 1 }, 1, {}, ?alloc$pool[0]]

Step 134:
  program counter:   1436
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (?alloc$pool[0], {}); insert first value into the second; push result ({ ?alloc$pool[0] })
  module:            __main__
  start statement:   line=27 column=9
  end statement:     line=27 column=66
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, { ?alloc$pool[0] }]

Step 135:
  program counter:   1437
  hvm code:          StoreVar $accu1189
  explanation:       pop value ({ ?alloc$pool[0] }) and store locally in variable \"$accu1189\"
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { $accu1189: { ?alloc$pool[0] } }
  stack:             [{:}, { 0, 1 }, 1]

Step 136:
  program counter:   1438
  hvm code:          Jump 1425
  explanation:       set program counter to 1425
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                             ^

Step 137:
  program counter:   1425
  hvm code:          Cut(tid)
  explanation:       pop index (1) and value ({ 0, 1 }); assign value (1) to tid; push new index (2) and True
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^
  method variables:  { $accu1189: { ?alloc$pool[0] }, tid: 1 }
  stack:             [{:}, { 0, 1 }, 2, True]

Step 138:
  program counter:   1426
  hvm code:          JumpCond False 1439
  explanation:       pop value (True), compare to False, and jump to 1439 if the same
  start expression:  line=27 column=21
  end expression:    line=27 column=24
  stack:             [{:}, { 0, 1 }, 2]

Step 139:
  program counter:   1427
  hvm code:          LoadVar $accu1189
  explanation:       push value ({ ?alloc$pool[0] }) of variable "$accu1189"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }]

Step 140:
  program counter:   1428
  hvm code:          DelVar $accu1189
  explanation:       delete method variable $accu1189
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { tid: 1 }

Step 141:
  program counter:   1429
  hvm code:          Push PC(1268)
  explanation:       push program counter constant 1268 (%+)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268)]

Step 142:
  program counter:   1430
  hvm code:          Push ?PC(1346)
  explanation:       push constant ?PC(1346)
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                            ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1346)]

Step 143:
  program counter:   1431
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                        ^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1346), 1]

Step 144:
  program counter:   1432
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=27 column=44
  end expression:    line=27 column=46
  method variables:  { }

Step 145:
  program counter:   1433
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1346)); push result (?PC(1346)[1])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                            ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, PC(1268), ?PC(1346)[1]]

Step 146:
  program counter:   1434
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?PC(1346)[1], PC(1268)); push result (?PC(1268)[?PC(1346)[1]])
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, ?PC(1268)[?PC(1346)[1]]]

Step 147:
  program counter:   1435
  hvm code:          Load
  explanation:       pop an argument (?PC(1346)[1]) and call method (1268: "fork")
  start expression:  line=27 column=21
  end expression:    line=27 column=48
  call trace:        main() --> fork(?PC(1346)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, ?PC(1346)[1]]

Step 148:
  program counter:   1268
  hvm code:          Frame fork(closure)
  explanation:       pop argument (?PC(1346)[1]), assign to closure, and run method "fork"
  module:            fork
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}]

Step 149:
  program counter:   1269
  hvm code:          Push PC(6)
  explanation:       push program counter constant 6 (%+)
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6)]

Step 150:
  program counter:   1270
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}]

Step 151:
  program counter:   1271
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema"]

Step 152:
  program counter:   1272
  hvm code:          Push PC(956)
  explanation:       push program counter constant 956 (%+)
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", PC(956)]

Step 153:
  program counter:   1273
  hvm code:          Push True
  explanation:       push constant True
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", PC(956), True]

Step 154:
  program counter:   1274
  hvm code:          2-ary Closure
  explanation:       pop 2 values (True, PC(956)); push result (?PC(956)[True])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", ?PC(956)[True]]

Step 155:
  program counter:   1275
  hvm code:          Load
  explanation:       pop an argument (True) and call method (956: "BinSema")
  start expression:  line=8 column=36
  end expression:    line=8 column=54
  call trace:        main() --> fork(?PC(1346)[1]) --> BinSema(True)
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, True]

Step 156:
  program counter:   956
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (True), assign to initial, and run method "BinSema"
  module:            synch
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: True }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }]

Step 157:
  program counter:   957
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 158:
  program counter:   958
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 159:
  program counter:   959
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True]

Step 160:
  program counter:   960
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True, {}]

Step 161:
  program counter:   961
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True, {}, False]

Step 162:
  program counter:   962
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True, { False }]

Step 163:
  program counter:   963
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True, { False }, True]

Step 164:
  program counter:   964
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True, { False, True }]

Step 165:
  program counter:   965
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, True); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True]

Step 166:
  program counter:   966
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }]

Step 167:
  program counter:   967
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 168:
  program counter:   968
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 169:
  program counter:   969
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }, True]

Step 170:
  program counter:   970
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 171:
  program counter:   971
  hvm code:          StoreVar sema
  explanation:       pop value (True) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: True }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", [], 20402, { "closure": ?PC(1346)[1] }]

Step 172:
  program counter:   972
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[1] }
  call trace:        main() --> fork(?PC(1346)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), {:}, "sema", True]

Step 173:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), { "sema": True }]

Step 174:
  program counter:   1277
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                         ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), { "sema": True }, "result"]

Step 175:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), { "sema": True }, "result", None]

Step 176:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "result", { "sema": True }); add key/value pair to dictionary; push result ({ "result": None, "sema": True })
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, PC(6), { "result": None, "sema": True }]

Step 177:
  program counter:   1280
  hvm code:          2-ary Closure
  explanation:       pop 2 values ({ "result": None, "sema": True }, PC(6)); push result (?PC(6)[{ "result": None, "sema": True }])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(6)[{ "result": None, "sema": True }]]

Step 178:
  program counter:   1281
  hvm code:          Load
  explanation:       pop an argument ({ "result": None, "sema": True }) and call method (6: "malloc")
  start expression:  line=8 column=14
  end expression:    line=8 column=72
  call trace:        main() --> fork(?PC(1346)[1]) --> malloc({ "result": None, "sema": True })
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "result": None, "sema": True }]

Step 179:
  program counter:   6
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "result": None, "sema": True }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "result": None, "sema": True } }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }]

Step 180:
  program counter:   7
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        main() --> fork(?PC(1346)[1]) --> malloc({ "result": None, "sema": True })

Step 181:
  program counter:   8
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool]

Step 182:
  program counter:   9
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool, 1]

Step 183:
  program counter:   10
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?alloc$pool); push result (?alloc$pool[1])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool[1]]

Step 184:
  program counter:   11
  hvm code:          LoadVar v
  explanation:       push value ({ "result": None, "sema": True }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool[1], { "result": None, "sema": True }]

Step 185:
  program counter:   12
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 186:
  program counter:   13
  hvm code:          Store
  explanation:       pop value ({ "result": None, "sema": True }) and address (?alloc$pool[1]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }]

Step 187:
  program counter:   14
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool]

Step 188:
  program counter:   15
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool, 1]

Step 189:
  program counter:   16
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?alloc$pool); push result (?alloc$pool[1])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, ?alloc$pool[1]]

Step 190:
  program counter:   17
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[1]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }]

Step 191:
  program counter:   18
  hvm code:          Load alloc$next
  explanation:       push value (1) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, 1]

Step 192:
  program counter:   19
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, 1, 1]

Step 193:
  program counter:   20
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }, 2]

Step 194:
  program counter:   21
  hvm code:          Store alloc$next
  explanation:       pop value (2) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, [], 20498, { "closure": ?PC(1346)[1] }]

Step 195:
  program counter:   22
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 196:
  program counter:   23
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[1] }
  call trace:        main() --> fork(?PC(1346)[1])
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?alloc$pool[1]]

Step 197:
  program counter:   1282
  hvm code:          StoreVar handle
  explanation:       pop value (?alloc$pool[1]) and store locally in variable \"handle\"
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                     ^^^^^^^^
  method variables:  { closure: ?PC(1346)[1], handle: ?alloc$pool[1] }
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}]

Step 198:
  program counter:   1283
  hvm code:          Push ?PC(1250)
  explanation:       push constant ?PC(1250)
  start statement:   line=9 column=5
  end statement:     line=9 column=34
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250)]

Step 199:
  program counter:   1284
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250), []]

Step 200:
  program counter:   1285
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1346)[1]) of variable "closure"
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250), [], ?PC(1346)[1]]

Step 201:
  program counter:   1286
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=9 column=19
  end expression:    line=9 column=25
  method variables:  { handle: ?alloc$pool[1] }

Step 202:
  program counter:   1287
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?PC(1346)[1], []); insert first value into the second; push result ([?PC(1346)[1]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[1] ]]

Step 203:
  program counter:   1288
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[1]) of variable "handle"
  source code:       spawn _helper(closure, handle)
                                            ^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[1] ], ?alloc$pool[1]]

Step 204:
  program counter:   1289
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?alloc$pool[1], [?PC(1346)[1]]); insert first value into the second; push result ([?PC(1346)[1], ?alloc$pool[1]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250), [ ?PC(1346)[1], ?alloc$pool[1] ]]

Step 205:
  program counter:   1290
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([?PC(1346)[1], ?alloc$pool[1]], ?PC(1250)); push result (?PC(1250)[[?PC(1346)[1], ?alloc$pool[1]]])
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250)[[ ?PC(1346)[1], ?alloc$pool[1] ]]]

Step 206:
  program counter:   1291
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn _helper(closure, handle)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}, ?PC(1250)[[ ?PC(1346)[1], ?alloc$pool[1] ]], {:}]

Step 207:
  program counter:   1292
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([?PC(1346)[1], ?alloc$pool[1]]), and pc (1250: "_helper"), and spawn thread
  start expression:  line=9 column=5
  end expression:    line=9 column=34
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, [], 22962, {:}]

Step 208:
  program counter:   1293
  hvm code:          ReturnOp(handle)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        main()
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0] }, ?alloc$pool[1]]

Step 209:
  program counter:   1436
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (?alloc$pool[1], { ?alloc$pool[0] }); insert first value into the second; push result ({ ?alloc$pool[0], ?alloc$pool[1] })
  module:            __main__
  start statement:   line=27 column=9
  end statement:     line=27 column=66
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 210:
  program counter:   1437
  hvm code:          StoreVar $accu1189
  explanation:       pop value ({ ?alloc$pool[0], ?alloc$pool[1] }) and store locally in variable \"$accu1189\"
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { $accu1189: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}, { 0, 1 }, 2]

Step 211:
  program counter:   1438
  hvm code:          Jump 1425
  explanation:       set program counter to 1425
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                                                             ^

Step 212:
  program counter:   1425
  hvm code:          Cut(tid)
  explanation:       pop index (2) and value ({ 0, 1 }); out of range -> push False
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^
  stack:             [{:}, False]

Step 213:
  program counter:   1426
  hvm code:          JumpCond False 1439
  explanation:       pop value (False), compare to False, and jump to 1439 if the same
  start expression:  line=27 column=21
  end expression:    line=27 column=24
  stack:             [{:}]

Step 214:
  program counter:   1439
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 215:
  program counter:   1440
  hvm code:          LoadVar $accu1189
  explanation:       push value ({ ?alloc$pool[0], ?alloc$pool[1] }) of variable "$accu1189"
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 216:
  program counter:   1441
  hvm code:          DelVar $accu1189
  explanation:       delete method variable $accu1189
  start expression:  line=27 column=21
  end expression:    line=27 column=65
  method variables:  { }

Step 217:
  program counter:   1442
  hvm code:          StoreVar tids
  explanation:       pop value ({ ?alloc$pool[0], ?alloc$pool[1] }) and store locally in variable \"tids\"
  source code:       let tids = {fork.fork(?incrementer(tid)) for tid in {0,1}}:
                     ^^^^^^^^^^
  method variables:  { tids: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}]

Step 218:
  program counter:   1443
  hvm code:          Push {}
  explanation:       initialize accumulator for set comprehension: push constant {}
  start statement:   line=28 column=18
  end statement:     line=28 column=49
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 219:
  program counter:   1444
  hvm code:          StoreVar $accu1211
  explanation:       pop value ({}) and store locally in variable \"$accu1211\"
  start expression:  line=28 column=19
  end expression:    line=28 column=48
  method variables:  { $accu1211: {}, tids: { ?alloc$pool[0], ?alloc$pool[1] } }
  stack:             [{:}]

Step 220:
  program counter:   1445
  hvm code:          LoadVar tids
  explanation:       push value ({ ?alloc$pool[0], ?alloc$pool[1] }) of variable "tids"
  source code:       {fork.join(tid) for tid in tids};
                                                ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }]

Step 221:
  program counter:   1446
  hvm code:          DelVar tids
  explanation:       delete method variable tids
  start expression:  line=28 column=45
  end expression:    line=28 column=48
  method variables:  { $accu1211: {} }

Step 222:
  program counter:   1447
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 0]

Step 223:
  program counter:   1448
  hvm code:          Cut(tid)
  explanation:       pop index (0) and value ({ ?alloc$pool[0], ?alloc$pool[1] }); assign value (?alloc$pool[0]) to tid; push new index (1) and True
  start expression:  line=28 column=19
  end expression:    line=28 column=22
  method variables:  { $accu1211: {}, tid: ?alloc$pool[0] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, True]

Step 224:
  program counter:   1449
  hvm code:          JumpCond False 1460
  explanation:       pop value (True), compare to False, and jump to 1460 if the same
  start expression:  line=28 column=19
  end expression:    line=28 column=22
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1]

Step 225:
  program counter:   1450
  hvm code:          LoadVar $accu1211
  explanation:       push value ({}) of variable "$accu1211"
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}]

Step 226:
  program counter:   1451
  hvm code:          DelVar $accu1211
  explanation:       delete method variable $accu1211
  start expression:  line=28 column=19
  end expression:    line=28 column=48
  method variables:  { tid: ?alloc$pool[0] }

Step 227:
  program counter:   1452
  hvm code:          Push PC(1296)
  explanation:       push program counter constant 1296 (%+)
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, PC(1296)]

Step 228:
  program counter:   1453
  hvm code:          LoadVar tid
  explanation:       push value (?alloc$pool[0]) of variable "tid"
  source code:       {fork.join(tid) for tid in tids};
                                ^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, PC(1296), ?alloc$pool[0]]

Step 229:
  program counter:   1454
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=28 column=29
  end expression:    line=28 column=31
  method variables:  { }

Step 230:
  program counter:   1455
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0], PC(1296)); push result (?PC(1296)[?alloc$pool[0]])
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, ?PC(1296)[?alloc$pool[0]]]

Step 231:
  program counter:   1456
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]) and call method (1296: "join")
  start expression:  line=28 column=19
  end expression:    line=28 column=32
  call trace:        main() --> join(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, ?alloc$pool[0]]

Step 232:
  program counter:   1296
  hvm code:          Frame join(meta)
  explanation:       pop argument (?alloc$pool[0]), assign to meta, and run method "join"
  module:            fork
  start statement:   line=11 column=1
  end statement:     line=11 column=30
  source code:       def join(meta) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { meta: ?alloc$pool[0] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}]

Step 233:
  program counter:   1297
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=12 column=5
  end statement:     line=12 column=30
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^

Step 234:
  program counter:   1298
  hvm code:          Push PC(998)
  explanation:       push program counter constant 998 (%+)
  start expression:  line=12 column=5
  end expression:    line=12 column=17
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(998)]

Step 235:
  program counter:   1299
  hvm code:          LoadVar meta
  explanation:       push value (?alloc$pool[0]) of variable "meta"
  source code:       synch.acquire(?meta->sema)
                                    ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(998), ?alloc$pool[0]]

Step 236:
  program counter:   1300
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       synch.acquire(?meta->sema)
                                          ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(998), ?alloc$pool[0], "sema"]

Step 237:
  program counter:   1301
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("sema", ?alloc$pool[0]); push result (?alloc$pool[0]["sema"])
  source code:       synch.acquire(?meta->sema)
                                    ^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(998), ?alloc$pool[0]["sema"]]

Step 238:
  program counter:   1302
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0]["sema"], PC(998)); push result (?PC(998)[?alloc$pool[0]["sema"]])
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, ?PC(998)[?alloc$pool[0]["sema"]]]

Step 239:
  program counter:   1303
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]["sema"]) and call method (998: "acquire")
  start expression:  line=12 column=5
  end expression:    line=12 column=30
  call trace:        main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, ?alloc$pool[0]["sema"]]

Step 240:
  program counter:   998
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?alloc$pool[0]["sema"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?alloc$pool[0]["sema"] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }]

================================================
Running thread T2: _helper(?PC(1346)[0], ?alloc$pool[0])
mode:  runnable
stack: ['[ ?PC(1346)[0], ?alloc$pool[0] ]']
other threads:
  T0: pc=1472 terminated atomic __init__()
  T1: pc=999 blocked main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T3: pc=1250 runnable _helper(?PC(1346)[1], ?alloc$pool[1])
    about to run method _helper with argument [ ?PC(1346)[1], ?alloc$pool[1] ]
shared variables:
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ]
  counter: 0
  in_cs: 0
  turn: 0
  wants: [ False, False ]
state id: 8
================================================

Step 241:
  program counter:   1250
  hvm code:          Frame _helper(closure, handle)
  explanation:       pop argument ([?PC(1346)[0], ?alloc$pool[0]]), assign to (closure, handle), and run method "_helper"
  module:            fork
  start statement:   line=3 column=1
  end statement:     line=3 column=29
  source code:       def _helper(closure, handle):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: ?PC(1346)[0], handle: ?alloc$pool[0] }
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0])
  stack:             [{:}]

Step 242:
  program counter:   1251
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  start statement:   line=4 column=5
  end statement:     line=4 column=29
  source code:       handle->result = !closure
                     ^^^^^^
  stack:             [{:}, ?alloc$pool[0]]

Step 243:
  program counter:   1252
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle->result = !closure
                             ^^^^^^
  stack:             [{:}, ?alloc$pool[0], "result"]

Step 244:
  program counter:   1253
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("result", ?alloc$pool[0]); push result (?alloc$pool[0]["result"])
  source code:       handle->result = !closure
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"]]

Step 245:
  program counter:   1254
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1346)[0]) of variable "closure"
  source code:       handle->result = !closure
                                       ^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], ?PC(1346)[0]]

Step 246:
  program counter:   1255
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=4 column=23
  end expression:    line=4 column=29
  method variables:  { handle: ?alloc$pool[0] }

Step 247:
  program counter:   1256
  hvm code:          Load
  explanation:       pop an argument (0) and call method (1346: "incrementer")
  source code:       handle->result = !closure
                                      ^^^^^^^^
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0]) --> incrementer(0)
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, 0]

Step 248:
  program counter:   1346
  hvm code:          Frame incrementer(tid)
  explanation:       pop argument (0), assign to tid, and run method "incrementer"
  module:            __main__
  start statement:   line=10 column=1
  end statement:     line=10 column=21
  source code:       def incrementer(tid):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 0 }
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }]

Step 249:
  program counter:   1347
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=11 column=6
  end statement:     line=11 column=31
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, {}]

Step 250:
  program counter:   1348
  hvm code:          Push False
  explanation:       push constant False
  source code:       while choose{False, True}:
                                  ^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, {}, False]

Step 251:
  program counter:   1349
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { False }]

Step 252:
  program counter:   1350
  hvm code:          Push True
  explanation:       push constant True
  source code:       while choose{False, True}:
                                         ^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { False }, True]

Step 253:
  program counter:   1351
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, { False, True }]

Step 254:
  program counter:   1352
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (False)
  source code:       while choose{False, True}:
                           ^^^^^^^^^^^^^^^^^^^
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0]) --> incrementer(0)
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }, False]

Step 255:
  program counter:   1353
  hvm code:          JumpCond False 1413
  explanation:       pop value (False), compare to False, and jump to 1413 if the same
  source code:       while choose{False, True}:
                     ^^^^^
  stack:             [{:}, ?alloc$pool[0]["result"], [], 20098, { "handle": ?alloc$pool[0] }]

Step 256:
  program counter:   1413
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start statement:   line=10 column=1
  end statement:     line=10 column=21
  source code:       def incrementer(tid):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }

Step 257:
  program counter:   1414
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start expression:  line=10 column=1
  end expression:    line=10 column=21
  method variables:  { handle: ?alloc$pool[0] }
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0])
  stack:             [{:}, ?alloc$pool[0]["result"], None]

Step 258:
  program counter:   1257
  hvm code:          Store
  explanation:       pop value (None) and address (?alloc$pool[0]["result"]) and store
  module:            fork
  start statement:   line=4 column=5
  end statement:     line=4 column=29
  source code:       handle->result = !closure
                     ^^^^^^^^^^^^^^^^
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0])
  stack:             [{:}]

Step 259:
  program counter:   1258
  hvm code:          Push PC(1017)
  explanation:       push program counter constant 1017 (%+)
  start statement:   line=5 column=5
  end statement:     line=5 column=32
  source code:       synch.release(?handle->sema)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(1017)]

Step 260:
  program counter:   1259
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  source code:       synch.release(?handle->sema)
                                    ^^^^^^
  stack:             [{:}, PC(1017), ?alloc$pool[0]]

Step 261:
  program counter:   1260
  hvm code:          DelVar handle
  explanation:       delete method variable handle
  start expression:  line=5 column=20
  end expression:    line=5 column=25
  method variables:  { }

Step 262:
  program counter:   1261
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       synch.release(?handle->sema)
                                            ^^^^
  stack:             [{:}, PC(1017), ?alloc$pool[0], "sema"]

Step 263:
  program counter:   1262
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("sema", ?alloc$pool[0]); push result (?alloc$pool[0]["sema"])
  source code:       synch.release(?handle->sema)
                                    ^^^^^^^^^^^^
  stack:             [{:}, PC(1017), ?alloc$pool[0]["sema"]]

Step 264:
  program counter:   1263
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0]["sema"], PC(1017)); push result (?PC(1017)[?alloc$pool[0]["sema"]])
  source code:       synch.release(?handle->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1017)[?alloc$pool[0]["sema"]]]

Step 265:
  program counter:   1264
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]["sema"]) and call method (1017: "release")
  start expression:  line=5 column=5
  end expression:    line=5 column=32
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0]) --> release(?alloc$pool[0]["sema"])
  stack:             [{:}, [], 20226, ?alloc$pool[0]["sema"]]

Step 266:
  program counter:   1017
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?alloc$pool[0]["sema"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?alloc$pool[0]["sema"] }
  stack:             [{:}, [], 20226, {:}]

Step 267:
  program counter:   1018
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0]) --> release(?alloc$pool[0]["sema"])

Step 268:
  program counter:   1019
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 269:
  program counter:   1020
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 270:
  program counter:   1021
  hvm code:          LoadVar binsema
  explanation:       push value (?alloc$pool[0]["sema"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 20226, {:}, ?alloc$pool[0]["sema"]]

Step 271:
  program counter:   1022
  hvm code:          Load
  explanation:       pop address (?alloc$pool[0]["sema"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 20226, {:}, True]

Step 272:
  program counter:   1023
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 20226, {:}]

Step 273:
  program counter:   1024
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 274:
  program counter:   1025
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 275:
  program counter:   1026
  hvm code:          LoadVar binsema
  explanation:       push value (?alloc$pool[0]["sema"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 20226, {:}, ?alloc$pool[0]["sema"]]

Step 276:
  program counter:   1027
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 277:
  program counter:   1028
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 20226, {:}, ?alloc$pool[0]["sema"], False]

Step 278:
  program counter:   1029
  hvm code:          Store
  explanation:       pop value (False) and address (?alloc$pool[0]["sema"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: [ { "result": None, "sema": False }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, [], 20226, {:}]

Step 279:
  program counter:   1030
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 280:
  program counter:   1031
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        _helper(?PC(1346)[0], ?alloc$pool[0])
  stack:             [{:}, None]

Step 281:
  program counter:   1265
  hvm code:          Pop
  explanation:       pop and discard value (%+)
  module:            fork
  start statement:   line=5 column=5
  end statement:     line=5 column=32
  source code:       synch.release(?handle->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 282:
  program counter:   1266
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=3 column=1
  end statement:     line=3 column=29
  source code:       def _helper(closure, handle):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  new mode:          terminated
  stack:             [None]

================================================
Running thread T3: _helper(?PC(1346)[1], ?alloc$pool[1])
mode:  runnable
stack: ['[ ?PC(1346)[1], ?alloc$pool[1] ]']
other threads:
  T0: pc=1472 terminated atomic __init__()
  T1: pc=999 runnable main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T2: pc=1266 terminated _helper(?PC(1346)[0], ?alloc$pool[0])
shared variables:
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": False }, { "result": None, "sema": True } ]
  counter: 0
  in_cs: 0
  turn: 0
  wants: [ False, False ]
state id: 39
================================================

Step 283:
  program counter:   1250
  hvm code:          Frame _helper(closure, handle)
  explanation:       pop argument ([?PC(1346)[1], ?alloc$pool[1]]), assign to (closure, handle), and run method "_helper"
  start expression:  line=3 column=1
  end expression:    line=3 column=29
  method variables:  { closure: ?PC(1346)[1], handle: ?alloc$pool[1] }
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1])
  stack:             [{:}]

Step 284:
  program counter:   1251
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[1]) of variable "handle"
  start statement:   line=4 column=5
  end statement:     line=4 column=29
  source code:       handle->result = !closure
                     ^^^^^^
  stack:             [{:}, ?alloc$pool[1]]

Step 285:
  program counter:   1252
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle->result = !closure
                             ^^^^^^
  stack:             [{:}, ?alloc$pool[1], "result"]

Step 286:
  program counter:   1253
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("result", ?alloc$pool[1]); push result (?alloc$pool[1]["result"])
  source code:       handle->result = !closure
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"]]

Step 287:
  program counter:   1254
  hvm code:          LoadVar closure
  explanation:       push value (?PC(1346)[1]) of variable "closure"
  source code:       handle->result = !closure
                                       ^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], ?PC(1346)[1]]

Step 288:
  program counter:   1255
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=4 column=23
  end expression:    line=4 column=29
  method variables:  { handle: ?alloc$pool[1] }

Step 289:
  program counter:   1256
  hvm code:          Load
  explanation:       pop an argument (1) and call method (1346: "incrementer")
  source code:       handle->result = !closure
                                      ^^^^^^^^
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, 1]

Step 290:
  program counter:   1346
  hvm code:          Frame incrementer(tid)
  explanation:       pop argument (1), assign to tid, and run method "incrementer"
  module:            __main__
  start statement:   line=10 column=1
  end statement:     line=10 column=21
  source code:       def incrementer(tid):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 1 }
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 291:
  program counter:   1347
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=11 column=6
  end statement:     line=11 column=31
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, {}]

Step 292:
  program counter:   1348
  hvm code:          Push False
  explanation:       push constant False
  source code:       while choose{False, True}:
                                  ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, {}, False]

Step 293:
  program counter:   1349
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { False }]

Step 294:
  program counter:   1350
  hvm code:          Push True
  explanation:       push constant True
  source code:       while choose{False, True}:
                                         ^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { False }, True]

Step 295:
  program counter:   1351
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       while choose{False, True}:
                                  ^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, { False, True }]

Step 296:
  program counter:   1352
  hvm code:          Choose
  explanation:       replace top of stack ({ False, True }) with choice (True)
  source code:       while choose{False, True}:
                           ^^^^^^^^^^^^^^^^^^^
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, True]

Step 297:
  program counter:   1353
  hvm code:          JumpCond False 1413
  explanation:       pop value (True), compare to False, and jump to 1413 if the same
  source code:       while choose{False, True}:
                     ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 298:
  program counter:   1354
  hvm code:          Push ?wants
  explanation:       push constant ?wants
  start statement:   line=12 column=10
  end statement:     line=12 column=26
  source code:       wants[tid] = True;
                     ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants]

Step 299:
  program counter:   1355
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       wants[tid] = True;
                           ^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants, 1]

Step 300:
  program counter:   1356
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?wants); push result (?wants[1])
  source code:       wants[tid] = True;
                     ^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants[1]]

Step 301:
  program counter:   1357
  hvm code:          Push True
  explanation:       push constant True
  source code:       wants[tid] = True;
                                  ^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants[1], True]

Step 302:
  program counter:   1358
  hvm code:          Store
  explanation:       pop value (True) and address (?wants[1]) and store
  source code:       wants[tid] = True;
                     ^^^^^^^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: [ { "result": None, "sema": False }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, True ] }
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 303:
  program counter:   1359
  hvm code:          Push ?wants
  explanation:       push constant ?wants
  start statement:   line=13 column=10
  end statement:     line=13 column=51
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                           ^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants]

Step 304:
  program counter:   1360
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                 ^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants, 1]

Step 305:
  program counter:   1361
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                   ^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants, 1, 1]

Step 306:
  program counter:   1362
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                 ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants, 0]

Step 307:
  program counter:   1363
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?wants); push result (?wants[0])
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                           ^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants[0]]

Step 308:
  program counter:   1364
  hvm code:          Load
  explanation:       pop address (?wants[0]) and push value (False)
  start expression:  line=13 column=16
  end expression:    line=13 column=27
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, False]

Step 309:
  program counter:   1365
  hvm code:          JumpCond True 1372
  explanation:       pop value (False), compare to True, and jump to 1372 if the same
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 310:
  program counter:   1366
  hvm code:          Load turn
  explanation:       push value (0) of variable turn
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                            ^^^^
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0]

Step 311:
  program counter:   1367
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                                     ^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0, 1]

Step 312:
  program counter:   1368
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                                         ^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0, 1, 1]

Step 313:
  program counter:   1369
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                                     ^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, 0, 0]

Step 314:
  program counter:   1370
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                            ^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, True]

Step 315:
  program counter:   1371
  hvm code:          Jump 1373
  explanation:       set program counter to 1373
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                                        ^^

Step 316:
  program counter:   1373
  hvm code:          JumpCond False 1391
  explanation:       pop value (True), compare to False, and jump to 1391 if the same
  source code:       while wants[1-tid] or (turn == (1 - tid)):
                     ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

Step 317:
  program counter:   1374
  hvm code:          Push ?wants
  explanation:       push constant ?wants
  start statement:   line=14 column=14
  end statement:     line=14 column=31
  source code:       wants[tid] = False;
                     ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants]

Step 318:
  program counter:   1375
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       wants[tid] = False;
                           ^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants, 1]

Step 319:
  program counter:   1376
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?wants); push result (?wants[1])
  source code:       wants[tid] = False;
                     ^^^^^^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants[1]]

Step 320:
  program counter:   1377
  hvm code:          Push False
  explanation:       push constant False
  source code:       wants[tid] = False;
                                  ^^^^^
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }, ?wants[1], False]

Step 321:
  program counter:   1378
  hvm code:          Store
  explanation:       pop value (False) and address (?wants[1]) and store
  source code:       wants[tid] = False;
                     ^^^^^^^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: [ { "result": None, "sema": False }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  call trace:        _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
  stack:             [{:}, ?alloc$pool[1]["result"], [], 20098, { "handle": ?alloc$pool[1] }]

================================================
Running thread T1: main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])
method variables:
  binsema: ?alloc$pool[0]["sema"]
mode:  runnable
stack: ['{:}', '{ ?alloc$pool[0], ?alloc$pool[1] }', '1', '{}', '[]', '23298', '{:}', '[]', '20850', '{ "meta": ?alloc$pool[0] }']
other threads:
  T0: pc=1472 terminated atomic __init__()
  T2: pc=1266 terminated _helper(?PC(1346)[0], ?alloc$pool[0])
  T3: pc=1379 blocked _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
    about to load variable turn
shared variables:
  alloc$next: 2
  alloc$pool: [ { "result": None, "sema": False }, { "result": None, "sema": True } ]
  counter: 0
  in_cs: 0
  turn: 0
  wants: [ False, False ]
state id: 153
================================================

Step 322:
  program counter:   999
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  module:            synch
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        main() --> join(?alloc$pool[0]) --> acquire(?alloc$pool[0]["sema"])

Step 323:
  program counter:   1000
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 324:
  program counter:   1001
  hvm code:          LoadVar binsema
  explanation:       push value (?alloc$pool[0]["sema"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }, ?alloc$pool[0]["sema"]]

Step 325:
  program counter:   1002
  hvm code:          Load
  explanation:       pop address (?alloc$pool[0]["sema"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }, False]

Step 326:
  program counter:   1003
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }, True]

Step 327:
  program counter:   1004
  hvm code:          JumpCond False 1006
  explanation:       pop value (True), compare to False, and jump to 1006 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }]

Step 328:
  program counter:   1005
  hvm code:          Jump 1009
  explanation:       set program counter to 1009
  source code:       atomically when not !binsema:
                                                ^

Step 329:
  program counter:   1009
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 330:
  program counter:   1010
  hvm code:          LoadVar binsema
  explanation:       push value (?alloc$pool[0]["sema"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }, ?alloc$pool[0]["sema"]]

Step 331:
  program counter:   1011
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 332:
  program counter:   1012
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }, ?alloc$pool[0]["sema"], True]

Step 333:
  program counter:   1013
  hvm code:          Store
  explanation:       pop value (True) and address (?alloc$pool[0]["sema"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: [ { "result": None, "sema": True }, { "result": None, "sema": True } ], counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[0] }]

Step 334:
  program counter:   1014
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 335:
  program counter:   1015
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { meta: ?alloc$pool[0] }
  call trace:        main() --> join(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, None]

Step 336:
  program counter:   1304
  hvm code:          Pop
  explanation:       pop and discard value (%+)
  module:            fork
  start statement:   line=12 column=5
  end statement:     line=12 column=30
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}]

Step 337:
  program counter:   1305
  hvm code:          LoadVar meta
  explanation:       push value (?alloc$pool[0]) of variable "meta"
  start statement:   line=13 column=5
  end statement:     line=13 column=25
  source code:       result = meta->result
                              ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, ?alloc$pool[0]]

Step 338:
  program counter:   1306
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       result = meta->result
                                    ^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, ?alloc$pool[0], "result"]

Step 339:
  program counter:   1307
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("result", ?alloc$pool[0]); push result (?alloc$pool[0]["result"])
  source code:       result = meta->result
                              ^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, ?alloc$pool[0]["result"]]

Step 340:
  program counter:   1308
  hvm code:          Load
  explanation:       pop address (?alloc$pool[0]["result"]) and push value (None)
  start expression:  line=13 column=14
  end expression:    line=13 column=25
  call trace:        main() --> join(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, None]

Step 341:
  program counter:   1309
  hvm code:          StoreVar result
  explanation:       pop value (None) and store locally in variable \"result\"
  source code:       result = meta->result
                     ^^^^^^^^
  method variables:  { meta: ?alloc$pool[0], result: None }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}]

Step 342:
  program counter:   1310
  hvm code:          Push PC(26)
  explanation:       push program counter constant 26 (%+)
  start statement:   line=14 column=5
  end statement:     line=14 column=20
  source code:       alloc.free(meta)
                     ^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(26)]

Step 343:
  program counter:   1311
  hvm code:          LoadVar meta
  explanation:       push value (?alloc$pool[0]) of variable "meta"
  source code:       alloc.free(meta)
                                ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, PC(26), ?alloc$pool[0]]

Step 344:
  program counter:   1312
  hvm code:          DelVar meta
  explanation:       delete method variable meta
  start expression:  line=14 column=16
  end expression:    line=14 column=19
  method variables:  { result: None }

Step 345:
  program counter:   1313
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[0], PC(26)); push result (?PC(26)[?alloc$pool[0]])
  source code:       alloc.free(meta)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, ?PC(26)[?alloc$pool[0]]]

Step 346:
  program counter:   1314
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[0]) and call method (26: "free")
  start expression:  line=14 column=5
  end expression:    line=14 column=20
  call trace:        main() --> join(?alloc$pool[0]) --> free(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 21026, ?alloc$pool[0]]

Step 347:
  program counter:   26
  hvm code:          Frame free(r)
  explanation:       pop argument (?alloc$pool[0]), assign to r, and run method "free"
  module:            alloc
  start statement:   line=13 column=1
  end statement:     line=13 column=12
  source code:       def free(r):
                     ^^^^^^^^^^^^
  method variables:  { r: ?alloc$pool[0] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 21026, { "result": None }]

Step 348:
  program counter:   27
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=14 column=5
  end statement:     line=14 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        main() --> join(?alloc$pool[0]) --> free(?alloc$pool[0])

Step 349:
  program counter:   28
  hvm code:          LoadVar r
  explanation:       push value (?alloc$pool[0]) of variable "r"
  start statement:   line=16 column=13
  end statement:     line=16 column=18
  source code:       del !r
                          ^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 21026, { "result": None }, ?alloc$pool[0]]

Step 350:
  program counter:   29
  hvm code:          DelVar r
  explanation:       delete method variable r
  start expression:  line=16 column=18
  end expression:    line=16 column=18
  method variables:  { }

Step 351:
  program counter:   30
  hvm code:          Del
  explanation:       pop an address and delete the shared variable at the address
  source code:       del !r
                     ^^^^^^
  shared variables:  { alloc$next: 2, alloc$pool: { 1: { "result": None, "sema": True } }, counter: 0, in_cs: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, [], 21026, { "result": None }]

Step 352:
  program counter:   31
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=14 column=5
  end statement:     line=14 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 353:
  program counter:   32
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=13 column=1
  end statement:     line=13 column=12
  source code:       def free(r):
                     ^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        main() --> join(?alloc$pool[0])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}, None]

Step 354:
  program counter:   1315
  hvm code:          Pop
  explanation:       pop and discard value (%+)
  module:            fork
  start statement:   line=14 column=5
  end statement:     line=14 column=20
  source code:       alloc.free(meta)
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, [], 23298, {:}]

Step 355:
  program counter:   1316
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=11 column=1
  end statement:     line=11 column=30
  source code:       def join(meta) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        main()
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, {}, None]

Step 356:
  program counter:   1457
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (None, {}); insert first value into the second; push result ({ None })
  module:            __main__
  start statement:   line=28 column=18
  end statement:     line=28 column=49
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1, { None }]

Step 357:
  program counter:   1458
  hvm code:          StoreVar $accu1211
  explanation:       pop value ({ None }) and store locally in variable \"$accu1211\"
  start expression:  line=28 column=19
  end expression:    line=28 column=48
  method variables:  { $accu1211: { None } }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 1]

Step 358:
  program counter:   1459
  hvm code:          Jump 1448
  explanation:       set program counter to 1448
  source code:       {fork.join(tid) for tid in tids};
                                                ^^^^

Step 359:
  program counter:   1448
  hvm code:          Cut(tid)
  explanation:       pop index (1) and value ({ ?alloc$pool[0], ?alloc$pool[1] }); assign value (?alloc$pool[1]) to tid; push new index (2) and True
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^
  method variables:  { $accu1211: { None }, tid: ?alloc$pool[1] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, True]

Step 360:
  program counter:   1449
  hvm code:          JumpCond False 1460
  explanation:       pop value (True), compare to False, and jump to 1460 if the same
  start expression:  line=28 column=19
  end expression:    line=28 column=22
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2]

Step 361:
  program counter:   1450
  hvm code:          LoadVar $accu1211
  explanation:       push value ({ None }) of variable "$accu1211"
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }]

Step 362:
  program counter:   1451
  hvm code:          DelVar $accu1211
  explanation:       delete method variable $accu1211
  start expression:  line=28 column=19
  end expression:    line=28 column=48
  method variables:  { tid: ?alloc$pool[1] }

Step 363:
  program counter:   1452
  hvm code:          Push PC(1296)
  explanation:       push program counter constant 1296 (%+)
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, PC(1296)]

Step 364:
  program counter:   1453
  hvm code:          LoadVar tid
  explanation:       push value (?alloc$pool[1]) of variable "tid"
  source code:       {fork.join(tid) for tid in tids};
                                ^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, PC(1296), ?alloc$pool[1]]

Step 365:
  program counter:   1454
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=28 column=29
  end expression:    line=28 column=31
  method variables:  { }

Step 366:
  program counter:   1455
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[1], PC(1296)); push result (?PC(1296)[?alloc$pool[1]])
  source code:       {fork.join(tid) for tid in tids};
                      ^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, ?PC(1296)[?alloc$pool[1]]]

Step 367:
  program counter:   1456
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[1]) and call method (1296: "join")
  start expression:  line=28 column=19
  end expression:    line=28 column=32
  call trace:        main() --> join(?alloc$pool[1])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, ?alloc$pool[1]]

Step 368:
  program counter:   1296
  hvm code:          Frame join(meta)
  explanation:       pop argument (?alloc$pool[1]), assign to meta, and run method "join"
  module:            fork
  start statement:   line=11 column=1
  end statement:     line=11 column=30
  source code:       def join(meta) returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { meta: ?alloc$pool[1] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}]

Step 369:
  program counter:   1297
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=12 column=5
  end statement:     line=12 column=30
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^

Step 370:
  program counter:   1298
  hvm code:          Push PC(998)
  explanation:       push program counter constant 998 (%+)
  start expression:  line=12 column=5
  end expression:    line=12 column=17
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, PC(998)]

Step 371:
  program counter:   1299
  hvm code:          LoadVar meta
  explanation:       push value (?alloc$pool[1]) of variable "meta"
  source code:       synch.acquire(?meta->sema)
                                    ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, PC(998), ?alloc$pool[1]]

Step 372:
  program counter:   1300
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       synch.acquire(?meta->sema)
                                          ^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, PC(998), ?alloc$pool[1], "sema"]

Step 373:
  program counter:   1301
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("sema", ?alloc$pool[1]); push result (?alloc$pool[1]["sema"])
  source code:       synch.acquire(?meta->sema)
                                    ^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, PC(998), ?alloc$pool[1]["sema"]]

Step 374:
  program counter:   1302
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?alloc$pool[1]["sema"], PC(998)); push result (?PC(998)[?alloc$pool[1]["sema"]])
  source code:       synch.acquire(?meta->sema)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, ?PC(998)[?alloc$pool[1]["sema"]]]

Step 375:
  program counter:   1303
  hvm code:          Load
  explanation:       pop an argument (?alloc$pool[1]["sema"]) and call method (998: "acquire")
  start expression:  line=12 column=5
  end expression:    line=12 column=30
  call trace:        main() --> join(?alloc$pool[1]) --> acquire(?alloc$pool[1]["sema"])
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, [], 20850, ?alloc$pool[1]["sema"]]

Step 376:
  program counter:   998
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?alloc$pool[1]["sema"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?alloc$pool[1]["sema"] }
  stack:             [{:}, { ?alloc$pool[0], ?alloc$pool[1] }, 2, { None }, [], 23298, {:}, [], 20850, { "meta": ?alloc$pool[1] }]

================================================
Final state
================================================
Threads:
  T0: pc=1472 terminated atomic __init__()
  T1: pc=999 blocked main() --> join(?alloc$pool[1]) --> acquire(?alloc$pool[1]["sema"])
    about to execute synch:35:     atomically when not !binsema:
  T2: pc=1266 terminated _helper(?PC(1346)[0], ?alloc$pool[0])
  T3: pc=1379 blocked _helper(?PC(1346)[1], ?alloc$pool[1]) --> incrementer(1)
    about to load variable turn
Variables:
  alloc$next: 2
  alloc$pool: { 1: { "result": None, "sema": True } }
  counter: 0
  in_cs: 0
  turn: 0
  wants: [ False, False ]

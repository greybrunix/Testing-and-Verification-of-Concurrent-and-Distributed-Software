Issue: Safety violation

Modules:
  alloc: /home/bdg/venv/lib/python3.10/site-packages/harmony_model_checker/modules/alloc.hny
  bag: /home/bdg/venv/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  __main__: dekker.hny
  synch: /home/bdg/venv/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  fork: /home/bdg/venv/lib/python3.10/site-packages/harmony_model_checker/modules/fork.hny
  list: /home/bdg/venv/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=38 column=7
  source code:       import fork
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push {:}
  explanation:       push constant {:}
  module:            alloc
  start statement:   line=1 column=1
  end statement:     line=1 column=10
  source code:       pool = {:}
                            ^^^
  stack:             [{:}, {:}]

Step 3:
  program counter:   2
  hvm code:          Store alloc$pool
  explanation:       pop value ({:}) and store into variable alloc$pool
  source code:       pool = {:}
                     ^^^^^^
  shared variables:  { alloc$pool: {:} }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=2 column=1
  end statement:     line=2 column=8
  source code:       next = 0
                            ^
  stack:             [{:}, 0]

Step 5:
  program counter:   4
  hvm code:          Store alloc$next
  explanation:       pop value (0) and store into variable alloc$next
  source code:       next = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 6:
  program counter:   5
  hvm code:          Jump 98
  explanation:       jump over method definition: set program counter to 98
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^

Step 7:
  program counter:   98
  hvm code:          Push PC(101)
  explanation:       push constant PC(101)
  module:            list
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(101)]

Step 8:
  program counter:   99
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (%+) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 9:
  program counter:   100
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 10:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(649)]

Step 11:
  program counter:   647
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (%+) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 12:
  program counter:   648
  hvm code:          Jump 668
  explanation:       jump over method definition: set program counter to 668
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 13:
  program counter:   668
  hvm code:          Push PC(671)
  explanation:       push constant PC(671)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(671)]

Step 14:
  program counter:   669
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (%+) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 15:
  program counter:   670
  hvm code:          Jump 690
  explanation:       jump over method definition: set program counter to 690
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 16:
  program counter:   690
  hvm code:          Push PC(693)
  explanation:       push constant PC(693)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(693)]

Step 17:
  program counter:   691
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (%+) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 18:
  program counter:   692
  hvm code:          Jump 709
  explanation:       jump over method definition: set program counter to 709
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 19:
  program counter:   709
  hvm code:          Push PC(712)
  explanation:       push constant PC(712)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(712)]

Step 20:
  program counter:   710
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (%+) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 21:
  program counter:   711
  hvm code:          Jump 737
  explanation:       jump over method definition: set program counter to 737
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 22:
  program counter:   737
  hvm code:          Push PC(740)
  explanation:       push constant PC(740)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(740)]

Step 23:
  program counter:   738
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (%+) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 24:
  program counter:   739
  hvm code:          Jump 766
  explanation:       jump over method definition: set program counter to 766
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 25:
  program counter:   766
  hvm code:          Push PC(769)
  explanation:       push constant PC(769)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(769)]

Step 26:
  program counter:   767
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (%+) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 27:
  program counter:   768
  hvm code:          Jump 1317
  explanation:       jump over method definition: set program counter to 1317
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 28:
  program counter:   1317
  hvm code:          Push 0
  explanation:       push constant 0
  module:            __main__
  start statement:   line=3 column=1
  end statement:     line=3 column=6
  source code:       crit=0
                          ^
  stack:             [{:}, 0]

Step 29:
  program counter:   1318
  hvm code:          Store crit
  explanation:       pop value (0) and store into variable crit
  source code:       crit=0
                     ^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, crit: 0 }
  stack:             [{:}]

Step 30:
  program counter:   1319
  hvm code:          Push ?wants
  explanation:       push constant ?wants
  start statement:   line=4 column=1
  end statement:     line=4 column=31
  source code:       sequential wants, turn, counter
                                ^^^^^
  stack:             [{:}, ?wants]

Step 31:
  program counter:   1320
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential wants, turn, counter
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 32:
  program counter:   1321
  hvm code:          Push ?turn
  explanation:       push constant ?turn
  source code:       sequential wants, turn, counter
                                       ^^^^
  stack:             [{:}, ?turn]

Step 33:
  program counter:   1322
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential wants, turn, counter
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 34:
  program counter:   1323
  hvm code:          Push ?counter
  explanation:       push constant ?counter
  source code:       sequential wants, turn, counter
                                             ^^^^^^^
  stack:             [{:}, ?counter]

Step 35:
  program counter:   1324
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential wants, turn, counter
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 36:
  program counter:   1325
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=5 column=1
  end statement:     line=5 column=22
  source code:       wants = (False, False)
                              ^^^^^^^^^^^^
  stack:             [{:}, []]

Step 37:
  program counter:   1326
  hvm code:          Push False
  explanation:       push constant False
  source code:       wants = (False, False)
                              ^^^^^
  stack:             [{:}, [], False]

Step 38:
  program counter:   1327
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  source code:       wants = (False, False)
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False ]]

Step 39:
  program counter:   1328
  hvm code:          Push False
  explanation:       push constant False
  source code:       wants = (False, False)
                                     ^^^^^
  stack:             [{:}, [ False ], False]

Step 40:
  program counter:   1329
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, [False]); insert first value into the second; push result ([False, False])
  source code:       wants = (False, False)
                              ^^^^^^^^^^^^
  stack:             [{:}, [ False, False ]]

Step 41:
  program counter:   1330
  hvm code:          Store wants
  explanation:       pop value ([False, False]) and store into variable wants
  source code:       wants = (False, False)
                     ^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, crit: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 42:
  program counter:   1331
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=6 column=1
  end statement:     line=6 column=8
  source code:       turn = 0
                            ^
  stack:             [{:}, 0]

Step 43:
  program counter:   1332
  hvm code:          Store turn
  explanation:       pop value (0) and store into variable turn
  source code:       turn = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, crit: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 44:
  program counter:   1333
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=8 column=1
  end statement:     line=8 column=11
  source code:       counter = 0
                               ^
  stack:             [{:}, 0]

Step 45:
  program counter:   1334
  hvm code:          Store counter
  explanation:       pop value (0) and store into variable counter
  source code:       counter = 0
                     ^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, counter: 0, crit: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 46:
  program counter:   1335
  hvm code:          Push 10
  explanation:       push constant 10
  start statement:   line=9 column=1
  end statement:     line=9 column=4
  source code:       I=10
                       ^^
  stack:             [{:}, 10]

Step 47:
  program counter:   1336
  hvm code:          Store I
  explanation:       pop value (10) and store into variable I
  source code:       I=10
                     ^^
  shared variables:  { I: 10, alloc$next: 0, alloc$pool: {:}, counter: 0, crit: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}]

Step 48:
  program counter:   1337
  hvm code:          Jump 1410
  explanation:       jump over method definition: set program counter to 1410
  start statement:   line=11 column=1
  end statement:     line=11 column=13
  source code:       def dekk p_q:
                     ^^^

Step 49:
  program counter:   1410
  hvm code:          Push PC(1268)
  explanation:       push program counter constant 1268 (%+)
  start statement:   line=34 column=1
  end statement:     line=34 column=20
  source code:       y = fork.fork dekk 0
                         ^^^^^^^^^
  stack:             [{:}, PC(1268)]

Step 50:
  program counter:   1411
  hvm code:          Push PC(1338)
  explanation:       push program counter constant 1338 (%+)
  source code:       y = fork.fork dekk 0
                                   ^^^^
  stack:             [{:}, PC(1268), PC(1338)]

Step 51:
  program counter:   1412
  hvm code:          2-ary Closure
  explanation:       pop 2 values (PC(1338), PC(1268)); push result (?PC(1268)[PC(1338)])
  source code:       y = fork.fork dekk 0
                         ^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1268)[PC(1338)]]

Step 52:
  program counter:   1413
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       y = fork.fork dekk 0
                                        ^
  stack:             [{:}, ?PC(1268)[PC(1338)], 0]

Step 53:
  program counter:   1414
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(1268)[PC(1338)]); push result (?PC(1268)[PC(1338)][0])
  source code:       y = fork.fork dekk 0
                         ^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1268)[PC(1338)][0]]

Step 54:
  program counter:   1415
  hvm code:          Load
  explanation:       pop an argument (PC(1338)) and call method (1268: "fork")
  start expression:  line=34 column=5
  end expression:    line=34 column=20
  call trace:        __init__() --> fork(PC(1338))
  stack:             [{:}, [ 0 ], 22642, PC(1338)]

Step 55:
  program counter:   1268
  hvm code:          Frame fork(closure)
  explanation:       pop argument (PC(1338)), assign to closure, and run method "fork"
  module:            fork
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: PC(1338) }
  stack:             [{:}, [ 0 ], 22642, {:}]

Step 56:
  program counter:   1269
  hvm code:          Push PC(6)
  explanation:       push program counter constant 6 (%+)
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6)]

Step 57:
  program counter:   1270
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}]

Step 58:
  program counter:   1271
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema"]

Step 59:
  program counter:   1272
  hvm code:          Push PC(956)
  explanation:       push program counter constant 956 (%+)
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", PC(956)]

Step 60:
  program counter:   1273
  hvm code:          Push True
  explanation:       push constant True
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                  ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", PC(956), True]

Step 61:
  program counter:   1274
  hvm code:          2-ary Closure
  explanation:       pop 2 values (True, PC(956)); push result (?PC(956)[True])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                    ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", ?PC(956)[True]]

Step 62:
  program counter:   1275
  hvm code:          Load
  explanation:       pop an argument (True) and call method (956: "BinSema")
  start expression:  line=8 column=36
  end expression:    line=8 column=54
  call trace:        __init__() --> fork(PC(1338)) --> BinSema(True)
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, True]

Step 63:
  program counter:   956
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (True), assign to initial, and run method "BinSema"
  module:            synch
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: True }
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }]

Step 64:
  program counter:   957
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 65:
  program counter:   958
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 66:
  program counter:   959
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True]

Step 67:
  program counter:   960
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True, {}]

Step 68:
  program counter:   961
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True, {}, False]

Step 69:
  program counter:   962
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True, { False }]

Step 70:
  program counter:   963
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True, { False }, True]

Step 71:
  program counter:   964
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True, { False, True }]

Step 72:
  program counter:   965
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, True); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True]

Step 73:
  program counter:   966
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }]

Step 74:
  program counter:   967
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 75:
  program counter:   968
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 76:
  program counter:   969
  hvm code:          LoadVar initial
  explanation:       push value (True) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }, True]

Step 77:
  program counter:   970
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 78:
  program counter:   971
  hvm code:          StoreVar sema
  explanation:       pop value (True) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: True }
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", [], 20402, { "closure": PC(1338) }]

Step 79:
  program counter:   972
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: PC(1338) }
  call trace:        __init__() --> fork(PC(1338))
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), {:}, "sema", True]

Step 80:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), { "sema": True }]

Step 81:
  program counter:   1277
  hvm code:          Push "result"
  explanation:       push constant "result"
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                         ^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), { "sema": True }, "result"]

Step 82:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                                                                  ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), { "sema": True }, "result", None]

Step 83:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "result", { "sema": True }); add key/value pair to dictionary; push result ({ "result": None, "sema": True })
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, PC(6), { "result": None, "sema": True }]

Step 84:
  program counter:   1280
  hvm code:          2-ary Closure
  explanation:       pop 2 values ({ "result": None, "sema": True }, PC(6)); push result (?PC(6)[{ "result": None, "sema": True }])
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(6)[{ "result": None, "sema": True }]]

Step 85:
  program counter:   1281
  hvm code:          Load
  explanation:       pop an argument ({ "result": None, "sema": True }) and call method (6: "malloc")
  start expression:  line=8 column=14
  end expression:    line=8 column=72
  call trace:        __init__() --> fork(PC(1338)) --> malloc({ "result": None, "sema": True })
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "result": None, "sema": True }]

Step 86:
  program counter:   6
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "result": None, "sema": True }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "result": None, "sema": True } }
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }]

Step 87:
  program counter:   7
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 88:
  program counter:   8
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool]

Step 89:
  program counter:   9
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool, 0]

Step 90:
  program counter:   10
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool[0]]

Step 91:
  program counter:   11
  hvm code:          LoadVar v
  explanation:       push value ({ "result": None, "sema": True }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool[0], { "result": None, "sema": True }]

Step 92:
  program counter:   12
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 93:
  program counter:   13
  hvm code:          Store
  explanation:       pop value ({ "result": None, "sema": True }) and address (?alloc$pool[0]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { I: 10, alloc$next: 0, alloc$pool: [ { "result": None, "sema": True } ], counter: 0, crit: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }]

Step 94:
  program counter:   14
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool]

Step 95:
  program counter:   15
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool, 0]

Step 96:
  program counter:   16
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, ?alloc$pool[0]]

Step 97:
  program counter:   17
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[0] }
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }]

Step 98:
  program counter:   18
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, 0]

Step 99:
  program counter:   19
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, 0, 1]

Step 100:
  program counter:   20
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }, 1]

Step 101:
  program counter:   21
  hvm code:          Store alloc$next
  explanation:       pop value (1) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { I: 10, alloc$next: 1, alloc$pool: [ { "result": None, "sema": True } ], counter: 0, crit: 0, turn: 0, wants: [ False, False ] }
  stack:             [{:}, [ 0 ], 22642, {:}, [], 20498, { "closure": PC(1338) }]

Step 102:
  program counter:   22
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 103:
  program counter:   23
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { closure: PC(1338) }
  call trace:        __init__() --> fork(PC(1338))
  stack:             [{:}, [ 0 ], 22642, {:}, ?alloc$pool[0]]

Step 104:
  program counter:   1282
  hvm code:          StoreVar handle
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"handle\"
  module:            fork
  start statement:   line=8 column=5
  end statement:     line=8 column=72
  source code:       handle = alloc.malloc({ .sema: synch.BinSema(True), .result: None })
                     ^^^^^^^^
  method variables:  { closure: PC(1338), handle: ?alloc$pool[0] }
  stack:             [{:}, [ 0 ], 22642, {:}]

Step 105:
  program counter:   1283
  hvm code:          Push ?PC(1250)
  explanation:       push constant ?PC(1250)
  start statement:   line=9 column=5
  end statement:     line=9 column=34
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250)]

Step 106:
  program counter:   1284
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250), []]

Step 107:
  program counter:   1285
  hvm code:          LoadVar closure
  explanation:       push value (PC(1338)) of variable "closure"
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250), [], PC(1338)]

Step 108:
  program counter:   1286
  hvm code:          DelVar closure
  explanation:       delete method variable closure
  start expression:  line=9 column=19
  end expression:    line=9 column=25
  method variables:  { handle: ?alloc$pool[0] }

Step 109:
  program counter:   1287
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (PC(1338), []); insert first value into the second; push result ([PC(1338)])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250), [ PC(1338) ]]

Step 110:
  program counter:   1288
  hvm code:          LoadVar handle
  explanation:       push value (?alloc$pool[0]) of variable "handle"
  source code:       spawn _helper(closure, handle)
                                            ^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250), [ PC(1338) ], ?alloc$pool[0]]

Step 111:
  program counter:   1289
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?alloc$pool[0], [PC(1338)]); insert first value into the second; push result ([PC(1338), ?alloc$pool[0]])
  source code:       spawn _helper(closure, handle)
                                   ^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250), [ PC(1338), ?alloc$pool[0] ]]

Step 112:
  program counter:   1290
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ([PC(1338), ?alloc$pool[0]], ?PC(1250)); push result (?PC(1250)[[PC(1338), ?alloc$pool[0]]])
  source code:       spawn _helper(closure, handle)
                           ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250)[[ PC(1338), ?alloc$pool[0] ]]]

Step 113:
  program counter:   1291
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn _helper(closure, handle)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ 0 ], 22642, {:}, ?PC(1250)[[ PC(1338), ?alloc$pool[0] ]], {:}]

Step 114:
  program counter:   1292
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg ([PC(1338), ?alloc$pool[0]]), and pc (1250: "_helper"), and spawn thread
  start expression:  line=9 column=5
  end expression:    line=9 column=34
  stack:             [{:}, [ 0 ], 22642, {:}]

Step 115:
  program counter:   1293
  hvm code:          ReturnOp(handle)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=33
  source code:       def fork(closure) returns handle:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__()
  stack:             [{:}, ??alloc$pool[0][0]]

Step 116:
  program counter:   1415
  hvm code:          Load
  explanation:       pop an address and push the value at the address
  module:            __main__
  start statement:   line=34 column=1
  end statement:     line=34 column=20
  source code:       y = fork.fork dekk 0
                         ^^^^^^^^^^^^^^^^
  new mode:          failed
  stack:             [{:}]
  operation failed:  Load ??alloc$pool[0][0]: can't load

================================================
Final state
================================================
Threads:
  T0: pc=1415 failed atomic __init__()
  T1: pc=1250 runnable _helper(PC(1338), ?alloc$pool[0])
    about to run method _helper with argument [ PC(1338), ?alloc$pool[0] ]
Variables:
  I: 10
  alloc$next: 1
  alloc$pool: [ { "result": None, "sema": True } ]
  counter: 0
  crit: 0
  turn: 0
  wants: [ False, False ]

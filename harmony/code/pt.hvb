Issue: Safety violation

Modules:
  __main__: pt.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=1 column=1
  end statement:     line=38 column=7
  source code:       in_cs = 0
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=1 column=1
  end statement:     line=1 column=9
  source code:       in_cs = 0
                             ^
  stack:             [{:}, 0]

Step 3:
  program counter:   2
  hvm code:          Store in_cs
  explanation:       pop value (0) and store into variable in_cs
  source code:       in_cs = 0
                     ^^^^^^^
  shared variables:  { in_cs: 0 }
  stack:             [{:}]

Step 4:
  program counter:   3
  hvm code:          Jump 58
  explanation:       jump over invariant definition: set program counter to 58
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                     ^^^^^^^^^

Step 5:
  program counter:   58
  hvm code:          Invariant 4
  explanation:       test invariant
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 6:
  program counter:   59
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=5 column=1
  end statement:     line=5 column=22
  source code:       sequential flags, turn
                                ^^^^^
  stack:             [{:}, ?flags]

Step 7:
  program counter:   60
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential flags, turn
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   61
  hvm code:          Push ?turn
  explanation:       push constant ?turn
  source code:       sequential flags, turn
                                       ^^^^
  stack:             [{:}, ?turn]

Step 9:
  program counter:   62
  hvm code:          Sequential
  explanation:       sequential consistency for variable on top of stack
  source code:       sequential flags, turn
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 10:
  program counter:   63
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=6 column=1
  end statement:     line=6 column=24
  source code:       flags = ( False, False )
                               ^^^^^^^^^^^^
  stack:             [{:}, []]

Step 11:
  program counter:   64
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = ( False, False )
                               ^^^^^
  stack:             [{:}, [], False]

Step 12:
  program counter:   65
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  source code:       flags = ( False, False )
                               ^^^^^^^^^^^^
  stack:             [{:}, [ False ]]

Step 13:
  program counter:   66
  hvm code:          Push False
  explanation:       push constant False
  source code:       flags = ( False, False )
                                      ^^^^^
  stack:             [{:}, [ False ], False]

Step 14:
  program counter:   67
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, [False]); insert first value into the second; push result ([False, False])
  source code:       flags = ( False, False )
                               ^^^^^^^^^^^^
  stack:             [{:}, [ False, False ]]

Step 15:
  program counter:   68
  hvm code:          Store flags
  explanation:       pop value ([False, False]) and store into variable flags
  source code:       flags = ( False, False )
                     ^^^^^^^
  shared variables:  { flags: [ False, False ], in_cs: 0 }
  stack:             [{:}]

Step 16:
  program counter:   69
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=7 column=1
  end statement:     line=7 column=23
  source code:       turn  = choose { 0, 1 }
                                      ^^^^
  stack:             [{:}, {}]

Step 17:
  program counter:   70
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       turn  = choose { 0, 1 }
                                      ^
  stack:             [{:}, {}, 0]

Step 18:
  program counter:   71
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (0, {}); insert first value into the second; push result ({ 0 })
  source code:       turn  = choose { 0, 1 }
                                      ^^^^
  stack:             [{:}, { 0 }]

Step 19:
  program counter:   72
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       turn  = choose { 0, 1 }
                                         ^
  stack:             [{:}, { 0 }, 1]

Step 20:
  program counter:   73
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (1, { 0 }); insert first value into the second; push result ({ 0, 1 })
  source code:       turn  = choose { 0, 1 }
                                      ^^^^
  stack:             [{:}, { 0, 1 }]

Step 21:
  program counter:   74
  hvm code:          Choose
  explanation:       replace top of stack ({ 0, 1 }) with choice (1)
  source code:       turn  = choose { 0, 1 }
                             ^^^^^^^^^^^^^^^
  call trace:        __init__()
  stack:             [{:}, 1]

Step 22:
  program counter:   75
  hvm code:          Store turn
  explanation:       pop value (1) and store into variable turn
  source code:       turn  = choose { 0, 1 }
                     ^^^^^^^
  shared variables:  { flags: [ False, False ], in_cs: 0, turn: 1 }
  stack:             [{:}]

Step 23:
  program counter:   76
  hvm code:          Jump 201
  explanation:       jump over method definition: set program counter to 201
  start statement:   line=8 column=1
  end statement:     line=8 column=16
  source code:       def thread self:
                     ^^^

Step 24:
  program counter:   201
  hvm code:          Push ?PC(77)
  explanation:       push constant ?PC(77)
  start statement:   line=35 column=1
  end statement:     line=35 column=14
  source code:       spawn thread 0
                           ^^^^^^
  stack:             [{:}, ?PC(77)]

Step 25:
  program counter:   202
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn thread 0
                                  ^
  stack:             [{:}, ?PC(77), 0]

Step 26:
  program counter:   203
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?PC(77)); push result (?PC(77)[0])
  source code:       spawn thread 0
                           ^^^^^^^^
  stack:             [{:}, ?PC(77)[0]]

Step 27:
  program counter:   204
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn thread 0
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(77)[0], {:}]

Step 28:
  program counter:   205
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (0), and pc (77: "thread"), and spawn thread
  start expression:  line=35 column=1
  end expression:    line=35 column=14
  stack:             [{:}]

Step 29:
  program counter:   206
  hvm code:          Push ?PC(77)
  explanation:       push constant ?PC(77)
  start statement:   line=36 column=1
  end statement:     line=36 column=14
  source code:       spawn thread 1
                           ^^^^^^
  stack:             [{:}, ?PC(77)]

Step 30:
  program counter:   207
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn thread 1
                                  ^
  stack:             [{:}, ?PC(77), 1]

Step 31:
  program counter:   208
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(77)); push result (?PC(77)[1])
  source code:       spawn thread 1
                           ^^^^^^^^
  stack:             [{:}, ?PC(77)[1]]

Step 32:
  program counter:   209
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn thread 1
                     ^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(77)[1], {:}]

Step 33:
  program counter:   210
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (77: "thread"), and spawn thread
  start expression:  line=36 column=1
  end expression:    line=36 column=14
  stack:             [{:}]

Step 34:
  program counter:   211
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=1 column=1
  end statement:     line=38 column=7
  source code:       in_cs = 0
  new mode:          terminated
  stack:             [None]

================================================
Running thread T3: invariant()
mode:  runnable atomic readonly
stack: ['[]']
other threads:
  T0: pc=211 terminated atomic __init__()
  T1: pc=77 runnable thread(0)
    about to run method thread with argument 0
  T2: pc=77 runnable thread(1)
    about to run method thread with argument 1
shared variables:
  flags: [ False, False ]
  in_cs: 0
  turn: 1
state id: 3
================================================

Step 35:
  program counter:   4
  hvm code:          Frame invariant()
  explanation:       pop argument () and run method "invariant"
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        invariant()
  stack:             [{:}]

Step 36:
  program counter:   5
  hvm code:          Push ()
  explanation:       initialize accumulator for list comprehension: push constant ()
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 37:
  program counter:   6
  hvm code:          StoreVar $accu5
  explanation:       pop value ([]) and store locally in variable \"$accu5\"
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { $accu5: [] }
  stack:             [{:}]

Step 38:
  program counter:   7
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                 ^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 39:
  program counter:   8
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                  ^^^
  stack:             [{:}, [], []]

Step 40:
  program counter:   9
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                  ^
  stack:             [{:}, [], [], 0]

Step 41:
  program counter:   10
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, []); insert first value into the second; push result ([0])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                  ^^^
  stack:             [{:}, [], [ 0 ]]

Step 42:
  program counter:   11
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                    ^
  stack:             [{:}, [], [ 0 ], 0]

Step 43:
  program counter:   12
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [0]); insert first value into the second; push result ([0, 0])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                  ^^^
  stack:             [{:}, [], [ 0, 0 ]]

Step 44:
  program counter:   13
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([0, 0], []); insert first value into the second; push result ([[0, 0]])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                 ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ] ]]

Step 45:
  program counter:   14
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                        ^^^
  stack:             [{:}, [ [ 0, 0 ] ], []]

Step 46:
  program counter:   15
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                        ^
  stack:             [{:}, [ [ 0, 0 ] ], [], 1]

Step 47:
  program counter:   16
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                        ^^^
  stack:             [{:}, [ [ 0, 0 ] ], [ 1 ]]

Step 48:
  program counter:   17
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                          ^
  stack:             [{:}, [ [ 0, 0 ] ], [ 1 ], 0]

Step 49:
  program counter:   18
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [1]); insert first value into the second; push result ([1, 0])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                        ^^^
  stack:             [{:}, [ [ 0, 0 ] ], [ 1, 0 ]]

Step 50:
  program counter:   19
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([1, 0], [[0, 0]]); insert first value into the second; push result ([[0, 0], [1, 0]])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                 ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ]]

Step 51:
  program counter:   20
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                              ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ], []]

Step 52:
  program counter:   21
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                              ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ], [], 1]

Step 53:
  program counter:   22
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                              ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ], [ 1 ]]

Step 54:
  program counter:   23
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                                ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ], [ 1 ], 1]

Step 55:
  program counter:   24
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [1]); insert first value into the second; push result ([1, 1])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                              ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ] ], [ 1, 1 ]]

Step 56:
  program counter:   25
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([1, 1], [[0, 0], [1, 0]]); insert first value into the second; push result ([[0, 0], [1, 0], [1, 1]])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                 ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ]]

Step 57:
  program counter:   26
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 0]

Step 58:
  program counter:   27
  hvm code:          Cut((C_1, C_2))
  explanation:       pop index (0) and value ([[0, 0], [1, 0], [1, 1]]); assign value ([0, 0]) to (C_1, C_2); push new index (1) and True
  start expression:  line=3 column=21
  end expression:    line=3 column=22
  method variables:  { $accu5: [], C_1: 0, C_2: 0 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, True]

Step 59:
  program counter:   28
  hvm code:          JumpCond False 44
  explanation:       pop value (True), compare to False, and jump to 44 if the same
  start expression:  line=3 column=21
  end expression:    line=3 column=22
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1]

Step 60:
  program counter:   29
  hvm code:          LoadVar $accu5
  explanation:       push value ([]) of variable "$accu5"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, []]

Step 61:
  program counter:   30
  hvm code:          DelVar $accu5
  explanation:       delete method variable $accu5
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { C_1: 0, C_2: 0 }

Step 62:
  program counter:   31
  hvm code:          LoadVar C_1
  explanation:       push value (0) of variable "C_1"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], 0]

Step 63:
  program counter:   32
  hvm code:          DelVar C_1
  explanation:       delete method variable C_1
  start expression:  line=3 column=25
  end expression:    line=3 column=27
  method variables:  { C_2: 0 }

Step 64:
  program counter:   33
  hvm code:          Apply PC(182)
  explanation:       pop an argument (0) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^
  call trace:        invariant() --> cs(0)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, 0]

Step 65:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (0), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 0 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }]

Step 66:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, ?flags]

Step 67:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, ?flags, 1]

Step 68:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (0) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, ?flags, 1, 0]

Step 69:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 1); the second integer minus the first; push result (1)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, ?flags, 1]

Step 70:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?flags); push result (?flags[1])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, ?flags[1]]

Step 71:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[1]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, False]

Step 72:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, True]

Step 73:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }]

Step 74:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 75:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }, True]

Step 76:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 530, { "C_2": 0 }]

Step 77:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { C_2: 0 }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], True]

Step 78:
  program counter:   34
  hvm code:          JumpCond False 39
  explanation:       pop value (True), compare to False, and jump to 39 if the same
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, []]

Step 79:
  program counter:   35
  hvm code:          LoadVar C_2
  explanation:       push value (0) of variable "C_2"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                          ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], 0]

Step 80:
  program counter:   36
  hvm code:          DelVar C_2
  explanation:       delete method variable C_2
  start expression:  line=3 column=38
  end expression:    line=3 column=40
  method variables:  { }

Step 81:
  program counter:   37
  hvm code:          Apply PC(182)
  explanation:       pop an argument (0) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                      ^^^^^^^^
  call trace:        invariant() --> cs(0)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, 0]

Step 82:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (0), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 0 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}]

Step 83:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, ?flags]

Step 84:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, ?flags, 1]

Step 85:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (0) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, ?flags, 1, 0]

Step 86:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 1); the second integer minus the first; push result (1)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, ?flags, 1]

Step 87:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?flags); push result (?flags[1])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, ?flags[1]]

Step 88:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[1]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, False]

Step 89:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, True]

Step 90:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}]

Step 91:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 92:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}, True]

Step 93:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], [], 594, {:}]

Step 94:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [], True]

Step 95:
  program counter:   38
  hvm code:          Jump 41
  explanation:       set program counter to 41
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                  ^^^

Step 96:
  program counter:   41
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (True, []); insert first value into the second; push result ([True])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1, [ True ]]

Step 97:
  program counter:   42
  hvm code:          StoreVar $accu5
  explanation:       pop value ([True]) and store locally in variable \"$accu5\"
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { $accu5: [ True ] }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 1]

Step 98:
  program counter:   43
  hvm code:          Jump 27
  explanation:       set program counter to 27
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                                  ^

Step 99:
  program counter:   27
  hvm code:          Cut((C_1, C_2))
  explanation:       pop index (1) and value ([[0, 0], [1, 0], [1, 1]]); assign value ([1, 0]) to (C_1, C_2); push new index (2) and True
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^
  method variables:  { $accu5: [ True ], C_1: 1, C_2: 0 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, True]

Step 100:
  program counter:   28
  hvm code:          JumpCond False 44
  explanation:       pop value (True), compare to False, and jump to 44 if the same
  start expression:  line=3 column=21
  end expression:    line=3 column=22
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2]

Step 101:
  program counter:   29
  hvm code:          LoadVar $accu5
  explanation:       push value ([True]) of variable "$accu5"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ]]

Step 102:
  program counter:   30
  hvm code:          DelVar $accu5
  explanation:       delete method variable $accu5
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { C_1: 1, C_2: 0 }

Step 103:
  program counter:   31
  hvm code:          LoadVar C_1
  explanation:       push value (1) of variable "C_1"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], 1]

Step 104:
  program counter:   32
  hvm code:          DelVar C_1
  explanation:       delete method variable C_1
  start expression:  line=3 column=25
  end expression:    line=3 column=27
  method variables:  { C_2: 0 }

Step 105:
  program counter:   33
  hvm code:          Apply PC(182)
  explanation:       pop an argument (1) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^
  call trace:        invariant() --> cs(1)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, 1]

Step 106:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (1), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 1 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }]

Step 107:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, ?flags]

Step 108:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, ?flags, 1]

Step 109:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, ?flags, 1, 1]

Step 110:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, ?flags, 0]

Step 111:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?flags); push result (?flags[0])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, ?flags[0]]

Step 112:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[0]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, False]

Step 113:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, True]

Step 114:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }]

Step 115:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 116:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }, True]

Step 117:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 530, { "C_2": 0 }]

Step 118:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { C_2: 0 }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], True]

Step 119:
  program counter:   34
  hvm code:          JumpCond False 39
  explanation:       pop value (True), compare to False, and jump to 39 if the same
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ]]

Step 120:
  program counter:   35
  hvm code:          LoadVar C_2
  explanation:       push value (0) of variable "C_2"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                          ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], 0]

Step 121:
  program counter:   36
  hvm code:          DelVar C_2
  explanation:       delete method variable C_2
  start expression:  line=3 column=38
  end expression:    line=3 column=40
  method variables:  { }

Step 122:
  program counter:   37
  hvm code:          Apply PC(182)
  explanation:       pop an argument (0) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                      ^^^^^^^^
  call trace:        invariant() --> cs(0)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, 0]

Step 123:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (0), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 0 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}]

Step 124:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, ?flags]

Step 125:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, ?flags, 1]

Step 126:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (0) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, ?flags, 1, 0]

Step 127:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (0, 1); the second integer minus the first; push result (1)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, ?flags, 1]

Step 128:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?flags); push result (?flags[1])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, ?flags[1]]

Step 129:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[1]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, False]

Step 130:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, True]

Step 131:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}]

Step 132:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 133:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}, True]

Step 134:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], [], 594, {:}]

Step 135:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True ], True]

Step 136:
  program counter:   38
  hvm code:          Jump 41
  explanation:       set program counter to 41
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                  ^^^

Step 137:
  program counter:   41
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (True, [True]); insert first value into the second; push result ([True, True])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2, [ True, True ]]

Step 138:
  program counter:   42
  hvm code:          StoreVar $accu5
  explanation:       pop value ([True, True]) and store locally in variable \"$accu5\"
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { $accu5: [ True, True ] }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 2]

Step 139:
  program counter:   43
  hvm code:          Jump 27
  explanation:       set program counter to 27
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                                  ^

Step 140:
  program counter:   27
  hvm code:          Cut((C_1, C_2))
  explanation:       pop index (2) and value ([[0, 0], [1, 0], [1, 1]]); assign value ([1, 1]) to (C_1, C_2); push new index (3) and True
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^
  method variables:  { $accu5: [ True, True ], C_1: 1, C_2: 1 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, True]

Step 141:
  program counter:   28
  hvm code:          JumpCond False 44
  explanation:       pop value (True), compare to False, and jump to 44 if the same
  start expression:  line=3 column=21
  end expression:    line=3 column=22
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3]

Step 142:
  program counter:   29
  hvm code:          LoadVar $accu5
  explanation:       push value ([True, True]) of variable "$accu5"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ]]

Step 143:
  program counter:   30
  hvm code:          DelVar $accu5
  explanation:       delete method variable $accu5
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { C_1: 1, C_2: 1 }

Step 144:
  program counter:   31
  hvm code:          LoadVar C_1
  explanation:       push value (1) of variable "C_1"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], 1]

Step 145:
  program counter:   32
  hvm code:          DelVar C_1
  explanation:       delete method variable C_1
  start expression:  line=3 column=25
  end expression:    line=3 column=27
  method variables:  { C_2: 1 }

Step 146:
  program counter:   33
  hvm code:          Apply PC(182)
  explanation:       pop an argument (1) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^
  call trace:        invariant() --> cs(1)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, 1]

Step 147:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (1), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 1 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }]

Step 148:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, ?flags]

Step 149:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, ?flags, 1]

Step 150:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, ?flags, 1, 1]

Step 151:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, ?flags, 0]

Step 152:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?flags); push result (?flags[0])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, ?flags[0]]

Step 153:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[0]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, False]

Step 154:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, True]

Step 155:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }]

Step 156:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 157:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }, True]

Step 158:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 530, { "C_2": 1 }]

Step 159:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { C_2: 1 }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], True]

Step 160:
  program counter:   34
  hvm code:          JumpCond False 39
  explanation:       pop value (True), compare to False, and jump to 39 if the same
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ]]

Step 161:
  program counter:   35
  hvm code:          LoadVar C_2
  explanation:       push value (1) of variable "C_2"
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                          ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], 1]

Step 162:
  program counter:   36
  hvm code:          DelVar C_2
  explanation:       delete method variable C_2
  start expression:  line=3 column=38
  end expression:    line=3 column=40
  method variables:  { }

Step 163:
  program counter:   37
  hvm code:          Apply PC(182)
  explanation:       pop an argument (1) and call method (182: "cs")
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                      ^^^^^^^^
  call trace:        invariant() --> cs(1)
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, 1]

Step 164:
  program counter:   182
  hvm code:          Frame cs(tid)
  explanation:       pop argument (1), assign to tid, and run method "cs"
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { tid: 1 }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}]

Step 165:
  program counter:   183
  hvm code:          Push ?flags
  explanation:       push constant ?flags
  start statement:   line=32 column=5
  end statement:     line=32 column=50
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, ?flags]

Step 166:
  program counter:   184
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, ?flags, 1]

Step 167:
  program counter:   185
  hvm code:          LoadVar tid
  explanation:       push value (1) of variable "tid"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                             ^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, ?flags, 1, 1]

Step 168:
  program counter:   186
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                         ^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, ?flags, 0]

Step 169:
  program counter:   187
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?flags); push result (?flags[0])
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                                  ^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, ?flags[0]]

Step 170:
  program counter:   188
  hvm code:          Load
  explanation:       pop address (?flags[0]) and push value (False)
  start expression:  line=32 column=18
  end expression:    line=32 column=32
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, False]

Step 171:
  program counter:   189
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                              ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, True]

Step 172:
  program counter:   190
  hvm code:          JumpCond True 196
  explanation:       pop value (True), compare to True, and jump to 196 if the same
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}]

Step 173:
  program counter:   196
  hvm code:          DelVar tid
  explanation:       delete method variable tid
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  method variables:  { }

Step 174:
  program counter:   197
  hvm code:          Push True
  explanation:       push constant True
  start expression:  line=32 column=13
  end expression:    line=32 column=50
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}, True]

Step 175:
  program counter:   198
  hvm code:          StoreVar tst3
  explanation:       pop value (True) and store locally in variable \"tst3\"
  source code:       tst3 =  (not flags (1 - tid)) or (turn == tid)
                     ^^^^^^
  method variables:  { tst3: True }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], [], 594, {:}]

Step 176:
  program counter:   199
  hvm code:          ReturnOp(tst3)
  explanation:       pop caller's method variables and pc and push result (%+), or terminate if no caller
  start statement:   line=31 column=1
  end statement:     line=31 column=24
  source code:       def cs tid returns tst3:
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        invariant()
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True ], True]

Step 177:
  program counter:   38
  hvm code:          Jump 41
  explanation:       set program counter to 41
  start statement:   line=3 column=1
  end statement:     line=3 column=96
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                  ^^^

Step 178:
  program counter:   41
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (True, [True, True]); insert first value into the second; push result ([True, True, True])
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3, [ True, True, True ]]

Step 179:
  program counter:   42
  hvm code:          StoreVar $accu5
  explanation:       pop value ([True, True, True]) and store locally in variable \"$accu5\"
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { $accu5: [ True, True, True ] }
  stack:             [{:}, [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ] ], 3]

Step 180:
  program counter:   43
  hvm code:          Jump 27
  explanation:       set program counter to 27
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                                  ^

Step 181:
  program counter:   27
  hvm code:          Cut((C_1, C_2))
  explanation:       pop index (3) and value ([[0, 0], [1, 0], [1, 1]]); out of range -> push False
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^
  stack:             [{:}, False]

Step 182:
  program counter:   28
  hvm code:          JumpCond False 44
  explanation:       pop value (False), compare to False, and jump to 44 if the same
  start expression:  line=3 column=21
  end expression:    line=3 column=22
  stack:             [{:}]

Step 183:
  program counter:   44
  hvm code:          DelVar C_1
  explanation:       delete method variable C_1
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 184:
  program counter:   45
  hvm code:          DelVar C_2
  explanation:       delete method variable C_2
  start expression:  line=3 column=21
  end expression:    line=3 column=78

Step 185:
  program counter:   46
  hvm code:          LoadVar $accu5
  explanation:       push value ([True, True, True]) of variable "$accu5"
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  stack:             [{:}, [ True, True, True ]]

Step 186:
  program counter:   47
  hvm code:          DelVar $accu5
  explanation:       delete method variable $accu5
  start expression:  line=3 column=21
  end expression:    line=3 column=78
  method variables:  { }

Step 187:
  program counter:   48
  hvm code:          1-ary any
  explanation:       pop a value ([True, True, True]); check if any value is True; push result (True)
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 188:
  program counter:   49
  hvm code:          JumpCond False 54
  explanation:       pop value (True), compare to False, and jump to 54 if the same
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 189:
  program counter:   50
  hvm code:          Load C_1
  explanation:       push value of shared variable C_1
  source code:       invariant not (any (cs (C_1) and cs (C_2) for (C_1,C_2) in [(0,0),(1,0),(1,1)]) => (C_1 == C_2))
                                                                                                         ^^^
  new mode:          failed
  operation failed:  Load: unknown variable ?C_1

================================================
Final state
================================================
Threads:
  T0: pc=211 terminated atomic __init__()
  T1: pc=77 runnable thread(0)
    about to run method thread with argument 0
  T2: pc=77 runnable thread(1)
    about to run method thread with argument 1
  T3: pc=50 failed atomic readonly invariant()
Variables:
  flags: [ False, False ]
  in_cs: 0
  turn: 1

Harmony

> Concurrent Programming Language
> model Checking
> Python-like
> Some (optional) quirks

@dekker.png

How does the model checker work?

> What it does 
           > Check for data races
           > Check for non terminating states in the NFA
           > Check for infinite loops
           > Check for active blocks
           > Provides a counterexample if one exists
           > Generates a html file, interactable if it finds a counterexample
           > Python-like syntax
           > Executable

> What it doesn't do
        > Model checker
           > Prove an algorithms safety and liveness properties
           > Does not prove tautologies
           > Propositions must be strong
           > Does not permit propositions 
           > As it is a SMT solver, it does not support temporal operators
	   > compatible with TLA+
        > Trace
           > Does not allow properties over NDA machines

#@charm.png

> What can we do?
           > Let's use some SMT theory
           > We know that Gamma |= b iff Gamma /\ ¬b |= absurd is unsatisfiable
           > Let's, then, formalize safety and liveness properties this way

Safety

Mutual Exclusion

FORALL (C1 C2 : Client), Crit(C1) /\ Crit(C2) -> C1 = C2
or
Crit_sec_counter IN {0,1}

Liveness

Lack of Deadlocks

Forall (C : Client) . Entering(C) -> Exists! (C1: Client) . Crit(C1)
note how this can become a safety property very easily

Lack of Starvation or Fairness

Forall (C : Client) . □(Wants(C) -> ◊(Crit(C))

SMT solvers cannot solve temporal operators like always(□) or eventually(◊)
but we may be able to, somehow, convert this proposition into a First Order Logic
Then we can use Harmony to prove the property applies to our mutex algorithms

@peterson.png

@fail.png

Alternative for Liveness Proof

Let us consider the NDA finite trace:
     > The lack of starvation implies a lack of trace where S1 -> ... -> S1
        without changing variable states
     > This means if it happened once it can happen again, and thus
       may happen an infinite amount of times

Thus our proposition looks like
FORALL S1, S1' : States , S1 = S1' /\ S1 -> ... -> S1' => state(var(S1)) != state(var(S1'))
       /\ FORALL C: Clients, wanted(C) => entered_once(C)

Summary

Mutex <=> i_var IN { 0 , 1 }
DeadLock <=> Forall (C : Client) . Entering(C) -> Exists! (C1: Client) . Crit(C1)
Fainess <=> FORALL S1, S1' : States , S1 = S1' /\ S1 -> ... -> S1' => state(var(S1)) != state(var(S1'))
       /\ FORALL C: Clients, wanted(C) => entered_once(C)

Harmony model checks through charm model checker
but it can compile to TLA code (TLC checker)
$ harmony -o Harmony.tla src.hny



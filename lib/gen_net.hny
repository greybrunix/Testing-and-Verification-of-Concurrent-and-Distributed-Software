import bag, list
# private variables
sequential net, id
net = {}
id = 0
dup = False
drop = False

def get_net() returns n:
	atomically n = net
# FL
def construct(flags) returns API:
	if (flags[0] == 0):
		atomically net = bag.empty()
		API = (send1, receive1)
		if (flags[1] == 2):
			spawn eternal duplicator1()
		elif (flags[1] == 1):
			dup = True
		if (flags[2] == 2):
			spawn eternal dropper1()
		elif (flags[2] == 1):
			drop = True
	else:
		net = []
		API = (send2, receive2)
		if (flags[1] == 2):
			spawn eternal duplicator2()
		elif (flags[1] == 1):
			dup = True
		if (flags[2] == 2):
			spawn eternal dropper2()
		elif (flags[2] == 1):
			drop = True


# public functions
def send1(src, dst, payload):
	atomically:
		var msg = {.src:src,.dst:dst,.payload:payload, .id:id}
		net = bag.add(net, msg)
		id += 1

def receive1(pid) returns msg:
	atomically:
		var msgs = { m:c for m:c in net where (pid == m.dst)}
		if msgs != {:}:
			msg = bag.bchoose msgs
		else:
			msg = {:}
def dropper1():
	while True:
		if (choose {True, False}):
			var net_cp = net
			when net_cp != net:
				if (net != bag.empty()):
					atomically:
						var msg_drop = bag.bchoose(net)
						net = bag.remove(net, msg_drop)

def duplicator1():
	while choose {True, False}:
		if (choose {True, False}):
			atomically var net_cp = net
			when net_cp != net:
				atomically:
					if (net != bag.empty()):
						var msg_dup = bag.bchoose(net)
						net = bag.add(net, msg_dup)

def send2(src, dst, payload):
	var msg = {.src:src, .dst:dst, .payload:payload, .id:id}
	atomically:
		net = net + [msg,]
		id += 1

def receive2(pid) returns msg:
	atomically:
		var msgs = [m for m in net where (pid == m.dst)]
		if len(msgs) > 0:
			msg = list.head(msgs)
			net = remove_msg(net, msg)
		else:
			msg = {:}
def remove_msg(L1, msg) returns L2:
	L2 = []
	var found_first = False
	for elem in L1:
		if (elem != msg) or (found_first):
			L2 += [elem,]
		elif (not found_first):
			found_first = True

